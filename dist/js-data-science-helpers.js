(()=>{var ud=Object.defineProperty;var ad=(t,e,n)=>e in t?ud(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var Nr=(t=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(t,{get:(e,n)=>(typeof require!="undefined"?require:e)[n]}):t)(function(t){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+t+'" is not supported')});var l=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports);var Ct=(t,e,n)=>(ad(t,typeof e!="symbol"?e+"":e,n),n);var ne=l((n2,wr)=>{var cd=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),kt=class extends Error{constructor(e){cd()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};wr.exports=kt});var d=l((r2,vr)=>{var ld=ne();vr.exports=function(t,e){if(!t)throw new ld(e)}});var p=l((s2,Sr)=>{function fd(t){try{return t instanceof Array||typeof t.constructor<"u"&&t.constructor.name==="Array"}catch{return!1}}Sr.exports=fd});var b=l((o2,xr)=>{function hd(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}xr.exports=hd});var _=l((i2,Tr)=>{function dd(t){return typeof t=="function"}Tr.exports=dd});var q=l((u2,Or)=>{function md(t){return typeof t=="number"&&!isNaN(t)}Or.exports=md});var N=l((a2,Dr)=>{function pd(t){return t===null||typeof t>"u"}Dr.exports=pd});var Y=l((c2,Fr)=>{var gd=p(),qd=N();function yd(t){return typeof t=="object"&&!qd(t)&&!gd(t)}Fr.exports=yd});var y=l((l2,Ir)=>{function bd(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}Ir.exports=bd});var ye=l((f2,Ar)=>{var Nd=d(),_r=p(),wd=b(),vd=_(),zt=q(),Er=Y(),Sd=y();function Rt(t,e){if(wd(t)){let o=Rt(t.values,e);return o.length>0&&zt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o.length>1&&zt(o[1])&&o[1]>=0&&o[1]<t.columns.length&&(o[1]=t.columns[o[1]]),o}if(Sd(t)){let o=Rt(t.values,e);return o.length>0&&zt(o[0])&&o[0]>=0&&o[0]<t.index.length&&(o[0]=t.index[o[0]]),o}if(Nd(Er(t)||_r(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!vd(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Er(o)){u.push(o);let a=Object.keys(o);for(let c=0;c<a.length;c++){let f=a[c],h=o[f];if(i(h))return[f];let m=n(h,i,u);if(m&&m.length>0)return[f].concat(m)}}else if(_r(o)){u.push(o);for(let a=0;a<o.length;a++){let c=o[a];if(i(c))return[a];let f=n(c,i,u);if(f&&f.length>0)return[a].concat(f)}}else if(i(o))return[];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ar.exports=Rt});var z=l((h2,zr)=>{var xd=ye(),jr=p(),Mr=b(),Cr=y();function re(t){try{return structuredClone(t)}catch{if(typeof t=="object"){if(t===null)return null;if(jr(t))return t.map(r=>re(r));if(Cr(t)){let r=t.copy();return r.values=re(r.values),r}if(Mr(t)){let r=t.copy();return r.values=re(t.values),r}t=kr(t);let n={};return Object.keys(t).forEach(r=>{n[r]=re(t[r])}),n}else return t}}function kr(t){function e(s,o,i){if(o=o||[],i=i||"",o.indexOf(s)>-1){let u=i.split("/").slice(i.startsWith("/")?1:0);if(u.some((c,f)=>{let h=u.slice(0,u.length-f-1),m=n;return h.forEach(g=>{m=m[g]}),m===s}))return`<reference to "${n===s?"/":"/"+xd(n,s).join("/")}">`}return typeof s=="object"?s===null?null:(o.push(s),jr(s)?s.map((u,a)=>e(u,o,i+"/"+a)):(Object.keys(s).forEach(u=>{s[u]=e(s[u],o,i+"/"+u)}),s)):s}let n=re(t),r=e(n);if(Mr(t)){let s=t.copy();s._values=r.values,s._columns=r.columns,s._index=r.index,r=s}if(Cr(t)){let s=t.copy();s.name=r.name,s._values=r.values,s._index=r.index,r=s}return r}zr.exports={copy:re,decycle:kr}});var T=l((d2,Br)=>{var{copy:Td}=z(),Od=d(),Rr=p(),Dd=b(),Fd=y();function Ur(t){if(Dd(t)||Fd(t))return Ur(t.values);Od(Rr(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(n){let r=[];return Td(n).forEach(s=>{Rr(s)?r=r.concat(e(s)):r.push(s)}),r}return e(t)}Br.exports=Ur});var C=l((m2,Vr)=>{var{decycle:Pr}=z();function Id(t,e){function n(r,s){let o=typeof r;if(o!==typeof s)return!1;if(o==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")return r.toString()==="NaN"&&s.toString()==="NaN"?!0:r===s;if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{let u=Object.keys(r),a=Object.keys(s);if(u.length!==a.length)return!1;for(let c=0;c<u.length;c++){let f=u[c];if(!n(r[f],s[f]))return!1}return!0}}}try{return t instanceof Date&&e instanceof Date?t.getTime()===e.getTime():n(t,e)}catch{return n(Pr(t),Pr(e))}}Vr.exports=Id});var k=l((p2,Gr)=>{var _d=d(),Ed=T(),Ad=p(),Jr=b(),jd=_(),Yr=y(),Md=N();function be(t){let e="abcdefg1234567890",n="";for(;n.length<t;)n+=e[parseInt(Math.random()*e.length)];return n}var Cd=be(256),kd=be(256),zd=be(256),Rd=be(256),Ud=be(256);function $r(t){if(Jr(t)||Yr(t))return $r(t.values);_d(Ad(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],n={};return Ed(t).forEach(r=>{let s=typeof r=="object"&&r===null?Cd:Md(r)?kd:jd(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Ud:r===1/0?zd:r===-1/0?Rd:Jr(r)?r.toJSONString():Yr(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||e.push(r),n[s]=!0}),e}Gr.exports=$r});var Ne=l((g2,Lr)=>{var Bd=d(),Ut=T(),Wr=p(),Pd=b(),Kr=C(),Vd=_(),Jd=y(),Yd=k();function Be(t,e){if(Pd(t)||Jd(t))return arguments.length>1?Be(t.values,e):Be(t.values,t.values);if(Bd(Wr(t),"The first argument to the `count` function must be an array, Series, or DataFrame!"),Vd(e))return Ut(t).filter(n=>e(n)).length;if(Wr(e)){let n=Ut(t);return Yd(e).map(r=>({value:r,count:n.filter(s=>Kr(s,r)).length}))}else return arguments.length>1?Ut(t).filter(n=>Kr(n,e)).length:Be(t,t)}Lr.exports=Be});var we=l((q2,Xr)=>{var $d=d(),Hr=p(),Gd=b(),Wd=y();function Bt(t){if(Gd(t)||Wd(t))return Bt(t.values);$d(Hr(t),"The `isJagged` function only works on arrays, Series, and DataFrames!");let e=0,n=null;for(let r=0;r<t.length;r++)if(Hr(t[r])){if(e++,Bt(t[r]))return!0;if(n===null)n=t[r].length;else if(t[r].length!==n)return!0}return e>0&&e<t.length}Xr.exports=Bt});var Pe=l((y2,es)=>{var Kd=d(),Zr=p(),Ld=b(),Hd=y();function Qr(t){if(Ld(t)||Hd(t))return Qr(t.values);Kd(Zr(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(Zr(t[e]))return!0;return!1}es.exports=Qr});var $=l((b2,ns)=>{var Q=d(),Xd=p(),Zd=Pe(),Qd=q(),e0=N(),se="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function ts(t){Q(!e0(t),se),Xd(t)||(t=[t]),Q(!Zd(t),se),Q(t.length>0,se);let e=t[0];if(Q(Qd(e),se),Q(parseInt(e)===e,se),Q(e>=0,se),Q(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let n=[];for(let r=0;r<e;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<e;r++)n.push(ts(t.slice(1)));return n}}ns.exports=ts});var ve=l((N2,rs)=>{var t0=d(),n0=p(),r0=b(),s0=y();function Pt(t){if(r0(t)||s0(t)){let n=t.copy();return n.values=Pt(n.values),n.index=Pt(n.index),n}t0(n0(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let n=t.length-1;n>=0;n--)e.push(t[n]);return e}rs.exports=Pt});var j=l((w2,ss)=>{var Vt=d(),Jt=q(),Yt=N(),o0=ve();function i0(t,e,n=1){Vt(!Yt(t)&&!Yt(e)&&!Yt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Vt(Jt(t)&&Jt(e)&&Jt(n),"You must pass two numbers and optionally a step value to the `range` function!"),Vt(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1;if(t>e){r=!0;let o=t;t=e+n,e=o+n}let s=[];for(let o=t;o<e;o+=n)s.push(o);return r&&(s=o0(s)),s}ss.exports=i0});var S=l((v2,as)=>{var u0=d(),os=p(),a0=b(),c0=C(),l0=y(),f0=N();function is(t){if(!os(t))return;let e=[t.length],n=0,r=t.map(s=>{let o=is(s);return f0(o)?o:(n++,o.length===1?o[0]:o)});return n>0?n===t.length&&r.slice(0,-1).every((o,i)=>c0(o,r[i+1]))?e.concat(r[0]):(e.push(r),e):e}function us(t){return a0(t)||l0(t)?us(t.values):(u0(os(t),"The `shape` function only works on arrays, Series, and DataFrames!"),is(t))}as.exports=us});var ms=l((S2,ds)=>{var cs=d(),h0=p(),d0=b(),m0=we(),p0=y(),g0=N(),ls=ne(),Ve=$(),fs=j(),q0=k(),y0=S();function hs(t,e,n){if(g0(n)&&(n=0),cs(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),h0(e)){cs(!m0(e),"The array of data you're trying to append to this DataFrame is jagged!");let r=y0(e);if(r.length===1)if(n===0){let s=t.copy();s._values.push(e);let o=Math.max(t.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(t.shape[0],r[0]),o=t.copy();for(fs(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Ve(t.shape[1])),o._values[i].push(e[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...e.map(i=>i.length).concat([t.shape[1]])),o=t.copy();for(o._values=o._values.concat(e).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...e.map(u=>u.length))+t.shape[1],o=Math.max(t.shape[0],r[0]),i=t.copy();for(fs(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Ve(t.shape[1])),i._values[u]=i._values[u].concat(e[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new ls("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(p0(e)){let r=hs(t,e.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(e.name)>-1?e.name+" (2)":e.name:r.columns[r.columns.length-1]=r.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,r}else if(d0(e))if(n===0){let r=t.copy(),s=q0(r._columns.concat(e._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),e.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let c=i._index.indexOf(a);c>-1?(u.push(i._values[c]),i._values.splice(c,1),i._index.splice(c,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(e._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(t._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=t.copy();return r._index.forEach((s,o)=>{let i=e._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(e._values[i]):r._values[o]=r._values[o].concat(Ve(e.shape[1]))}),e._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Ve(r._columns.length).concat(e._values[o])))}),r._columns=r._columns.concat(e._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new ls("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}ds.exports=hs});var bs=l((x2,ys)=>{var ps=d(),gs=p(),b0=_(),qs=N();function N0(t,e,n,r,s){if(s=s||0,ps(b0(r),"The first parameter to the `apply` method must be a function."),ps(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let c=new e(n.values.map(h=>h[a]));c.name=u,c.index=n.index;let f=r(c,a,n);f instanceof e?o[u]=f.values:o[u]=f,qs(i)&&(i=f instanceof e||gs(f))}),i){let u=new t(o);return u.index=n.index,u}else{let u=new e(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let c=new e(u);c.name=n.index[a],c.index=n.columns;let f=r(c,a,n);return qs(o)&&(o=f instanceof e||gs(f)),f instanceof e?f.values:f});if(o){let u=new t(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new e(i);return u.index=n.index,u}}}ys.exports=N0});var E=l((T2,Ns)=>{function w0(t){return typeof t=="string"}Ns.exports=w0});var Ss=l((O2,vs)=>{var ws=d(),v0=p(),S0=we(),x0=Y(),T0=E(),O0=N(),D0=ne(),F0=S();function I0(t,e,n,r,s){let o=u=>u instanceof t,i=u=>u instanceof e;if(O0(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(x0(r)){let u=Math.max(...Object.keys(r).map(a=>r[a].length));return Object.keys(r).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new t(r),1)}else throw new D0("You must pass a DataFrame, Series, or object into the `assign` method!")}else{ws(T0(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),ws(v0(s)&&!S0(s)&&F0(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}vs.exports=I0});var Ts=l((D2,xs)=>{var{copy:_0}=z();function E0(t,e){if(e.isEmpty)return new t;let n=new t(_0(e.values));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}xs.exports=E0});var As=l((F2,Es)=>{var Je=d(),Os=p(),Ds=q(),Fs=E(),Is=N(),_s=S();function A0(t,e,n,r,s){Is(r)&&(r=[]),Is(s)&&(s=[]),(Fs(r)||Ds(r))&&(r=[r]),(Fs(s)||Ds(s))&&(s=[s]),Je(Os(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(Os(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(_s(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),Je(_s(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,c)=>{r.indexOf(a)<0&&r.indexOf(c)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,c)=>{s.indexOf(a)<0&&s.indexOf(c)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof e){let a=new t;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}Es.exports=A0});var Se=l((I2,js)=>{var j0=q();function M0(t){return j0(t)&&parseInt(t)===t}function C0(t){return M0(t)&&t>=0}js.exports=C0});var Cs=l((_2,Ms)=>{var $t=d(),k0=E(),Ye=N(),z0=Se(),R0=S();function U0(t,e,n,r,s,o){r=r||0,$t(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,$t(z0(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",$t(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(c){if(o>0){let f=0;for(let h=0;h<c.length;h++){let m=c[h];if(Ye(m)&&f++,f>=o)return[]}}else if(s==="any")for(let f=0;f<c.length;f++){let h=c[f];if(Ye(h))return[]}else if(s==="all"){for(let f=0;f<c.length;f++){let h=c[f];if(!Ye(h))return c}return[]}return c}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let c=u.values.map(i).filter(h=>h.length>0);if(R0(c).length<2)return new t;u.values=c;let f=u.get(null,a);if(Ye(f))return new t;k0(f)&&(f=[f]),f instanceof e&&(f=f.values),u.index=f,u=u.drop(null,a)}else if(r===1){let c={};if(u.columns.forEach((h,m)=>{let g=u.values.map(O=>O[m]),F=i(g);F.length>0&&(c[h]=F)}),Object.keys(c).length===0)return new t;let f=new t(c);return f.index=u.index,f}return u}Ms.exports=U0});var Gt=l((E2,zs)=>{var B0=d(),P0=p(),V0=b(),J0=q(),Y0=y();function ks(t){if(V0(t)||Y0(t))return t.dropNaN(...Object.values(arguments).slice(1));B0(P0(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(ks(n))}catch{if(J0(n))return e.push(n)}}),e}zs.exports=ks});var Us=l((A2,Rs)=>{var Wt=d(),$0=Gt(),G0=Se();function W0(t,e,n,r,s){n=n||0,Wt(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,Wt(G0(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",Wt(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=$0(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=e.copy();if(n===0){let u=i.index.filter(a=>{let c=i.get(a,null).values;return o(c)});return u.length>0?i.get(u,null):new t}else if(n===1){let u=i.columns.filter(a=>{let c=i.get(null,a).values;return o(c)});return u.length>0?i.get(null,u):new t}return i}Rs.exports=W0});var Js=l((j2,Vs)=>{var Bs=d(),xe=T(),K0=_(),L0=N();function Ps(t){let e={};return xe(t).forEach((n,r)=>{e[n]=r}),e}function oe(t){return Object.keys(t).sort((e,n)=>t[e]-t[n])}function H0(t,e,n,r,s){Bs(K0(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),L0(s)&&(s=0),Bs(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Ps(o.index),u=Ps(o.columns);if(s===0){let a=o.values.filter((c,f)=>{let h=new e(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m||delete i[o.index[f]],m});if(xe(a).length===0)return new t;if(a.length===1){let c=new e(xe(a));return c.name=oe(i)[0],c.index=oe(u),c}o.values=a,o.index=oe(i)}else if(s===1){o=o.transpose();let a=o.values.filter((c,f)=>{let h=new e(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m||delete u[o.index[f]],m});if(xe(a).length===0)return new t;if(a.length===1){let c=new e(xe(a));return c.name=oe(u)[0],c.index=oe(i),c}o.values=a,o.index=oe(u),o=o.transpose()}return o}Vs.exports=H0});var Gs=l((M2,$s)=>{var M=d(),$e=q(),Ge=E(),Ys=N(),X0=k();function Z0(t,e,n){(Ge(e)||$e(e))&&(e=[e]),(Ge(n)||$e(n))&&(n=[n]);let r=X0((e||[]).concat(n||[]).map(s=>typeof s));return M(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&M(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(M(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),M(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Ys(e)||(e=e.map(s=>{if(Ge(s))return M(t.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if($e(s))return M(s>=0,`Index ${s} is out of bounds!`),M(parseInt(s)===s,"Row numbers must be integers!"),M(s<t.index.length,`Index ${s} is out of bounds!`),t.index[s]})),Ys(n)||(n=n.map(s=>{if(Ge(s))return M(t.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if($e(s))return M(s>=0,`Column ${s} is out of bounds!`),M(parseInt(s)===s,"Column numbers must be integers!"),M(s<t.columns.length,`Column ${s} is out of bounds!`),t.columns[s]})),t.getSubsetByNames(e,n)}$s.exports=Z0});var G=l((C2,Ks)=>{var Ws=d(),Q0=p(),em=b(),tm=_(),nm=y(),rm=N();function sm(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function om(t,e){if(rm(e)&&(e=sm),em(t)||nm(t))return t.sort(...Object.values(arguments).slice(1));Ws(Q0(t),"The `sort` function only works on arrays, Series, and DataFrames!"),Ws(tm(e),"The second parameter of the `sort` function must be a comparison function!");let n=t.slice();return n.sort(e),n}Ks.exports=om});var Zs=l((k2,Xs)=>{var Ls=d(),Hs=E(),im=N(),um=k(),am=G();function cm(t){let e=t.toLowerCase(),n="";for(let s=0;s<e.length;s++){let o=e[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function lm(t,e,n){im(n)?n=e.columns:Hs(n)&&(n=[n]);let r={};n.forEach(o=>{Ls(Hs(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=e.columns.indexOf(o);Ls(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=e.values.map(c=>c[i]),a=am(um(u));u.forEach(c=>{a.forEach(f=>{let h=o+"_"+cm(f.toString());r[h]||(r[h]=[]),c===f?r[h].push(1):r[h].push(0)})})});let s=new t(r);return s.index=e.index,s}Xs.exports=lm});var io=l((z2,oo)=>{var W=d(),Qs=p(),eo=q(),to=N(),no=Se(),ro=j(),so=S();function fm(t,e,n){let r=t.shape;to(e)&&(e=ro(0,r[0])),to(n)&&(n=ro(0,r[1])),eo(e)&&(e=[e]),eo(n)&&(n=[n]),W(Qs(e)&&Qs(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),W(so(e).length===1&&so(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),W(e.length>0,"The `rowIndices` array must contain at least one index."),W(n.length>0,"The `colIndices` array must contain at least one index."),e.forEach(i=>{W(no(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),W(i<t.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{W(no(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),W(i<t.columns.length,`The column index ${i} is out of bounds.`)});let s=e.map(i=>t.index[i]),o=n.map(i=>t.columns[i]);return t.getSubsetByNames(s,o)}oo.exports=fm});var fo=l((R2,lo)=>{var K=d(),Kt=T(),uo=p(),We=E(),ao=N(),co=S();function hm(t,e,n,r,s){ao(r)&&(r=n.index),ao(s)&&(s=n.columns),We(r)&&(r=[r]),We(s)&&(s=[s]),K(uo(r)&&uo(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(co(r).length===1&&co(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(r.length>0,"The `rows` array must contain at least one row name."),K(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{K(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{K(We(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),K(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return Kt(o)[0];if(r.length===1){let u=new e(Kt(o));return u.name=r[0],u.index=s,u}if(s.length===1){let u=new e(Kt(o));return u.name=s[0],u.index=r,u}let i=new t(o);return i.columns=s,i.index=r,i}lo.exports=hm});var mo=l((U2,ho)=>{var dm=E(),Te=j();function mm(t,e,n){function r(m,g){return dm(m)&&m.length>g?m.substring(0,g-3)+"...":m}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=parseInt(s/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=parseInt(i/2),a=s>n.index.length?null:Te(0,o).concat(Te(n.index.length-o,n.index.length)),c=i>n.columns.length?null:Te(0,u).concat(Te(n.columns.length-u,n.columns.length)),f=n.get(a,c);f instanceof e&&(n.shape[0]===1?(f=new t([f.values]),f.index=n.index,f.columns=new e(n.columns).get(c).values):n.shape[1]===1&&(f=new t([f.values]).transpose(),f.index=new e(n.index).get(a).values,f.columns=n.columns)),s<=n.index.length&&(f._index.splice(o,0,"..."),f._values.splice(o,0,Te(0,f.columns.length).map(()=>"..."))),i<=n.columns.length&&(f._columns.splice(u,0,"..."),f._values=f._values.map(m=>(m.splice(u,0,"..."),m)));let h=28;return f instanceof e?(f.values=f.values.map(m=>r(m,h)),f.name=r(f.name,h),f.index=f.index.map(m=>r(m,h))):(f.values=f.values.map(m=>m.map(g=>r(g,h))),f.columns=f.columns.map(m=>r(m,h)),f.index=f.index.map(m=>r(m,h))),console.table(f.toObject()),console.log("Shape:",n.shape,`
`),n}ho.exports=mm});var Ke=l((B2,po)=>{var pm=d(),gm=q();function qm(t,e){pm(gm(t),"The `leftPad` function only works on numbers!");let n=t.toString();for(;n.length<e;)n="0"+n;return n}po.exports=qm});var qo=l((P2,go)=>{var ym=Ke(),bm=j();function Nm(t,e){let n=e?t:t.copy();return n.index=bm(0,t.shape[0]).map(r=>"row"+ym(r,(n.index.length-1).toString().length)),n}go.exports=Nm});var Oe=l((V2,bo)=>{var wm=d(),vm=T(),Sm=p(),xm=b(),Tm=y();function yo(t){if(xm(t)||Tm(t))return yo(t.values);wm(Sm(t),"The `product` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:vm(t).reduce((e,n)=>e*n,1)}catch{return NaN}}bo.exports=yo});var Le=l((J2,So)=>{var De=d(),No=T(),wo=p(),Om=b(),vo=q(),Dm=y(),Fm=Oe(),Im=S();function Lt(t,e){if(Om(t)||Dm(t))return Lt(t.values,e);if(De(wo(t),"The first argument passed into the `reshape` function must be an array!"),vo(e)&&(e=[e]),De(wo(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),De(Im(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e.forEach(o=>{De(vo(o)&&parseInt(o)===o&&o>0,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!")}),e.length===0)return No(t);let n=No(t);if(e.length===1&&e[0]===n.length)return n;De(Fm(e)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=parseInt(n.length/e[0]);for(let o=0;o<e[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(Lt(i,e.slice(1)))}return r}So.exports=Lt});var ie=l((Y2,_o)=>{var{copy:Oo}=z(),_m=d(),Em=p(),Am=q(),Do=N(),jm=$(),Mm=Oe(),Cm=Le(),Fo=Math.pow(2,64),x=[];Io(parseInt(Math.random()*Fo));function km(t,e){t=I(t);function n(){t+=I("0x9e3779b97f4a7c15");let s=Oo(t);return s=(s^s>>BigInt(30))*I("0xbf58476d1ce4e5b9"),s=(s^s>>BigInt(27))*I("0x94d049bb133111eb"),s^s>>BigInt(31)}let r=[];for(let s=0;s<e;s++)r.push(n());return r}function I(t){return BigInt.asUintN(64,BigInt(t))}function xo(t,e){return t=I(t),e=BigInt(e),I(I(t<<e)|I(t>>I(BigInt(64)-e)))}function Io(t){if(Do(t))return Oo(x);{_m(Am(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=km(parseInt(t),4);x[0]=e[0],x[1]=e[1],x[2]=e[2],x[3]=e[3]}}function To(){let t=I(xo(x[0]+x[3],23)+x[0]),e=I(x[1]<<BigInt(17));return x[2]=I(x[2]^x[0]),x[3]=I(x[3]^x[1]),x[1]=I(x[1]^x[2]),x[0]=I(x[0]^x[3]),x[2]=I(x[2]^e),x[3]=xo(x[3],45),parseInt(t)/Fo}function zm(t){return Do(t)?To():(Em(t)||(t=[t]),Cm(jm(Mm(t)).map(To),t))}_o.exports={random:zm,seed:Io}});var He=l(($2,Eo)=>{var{random:Rm}=ie(),Um=d(),Bm=p(),Pm=b(),Vm=y();function Jm(t){if(Pm(t)||Vm(t))return t.shuffle(...Object.values(arguments).slice(1));Um(Bm(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],n=t.slice();for(let r=0;r<t.length;r++){let s=parseInt(Rm()*n.length);e.push(n.splice(s,1)[0])}return e}Eo.exports=Jm});var Mo=l((G2,jo)=>{var Ym=d(),$m=N(),Ao=He();function Gm(t,e){return $m(e)&&(e=0),Ym(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?Ao(t.index):null,e===1?Ao(t.columns):null)}jo.exports=Gm});var Xe=l((W2,Co)=>{function Wm(t){return typeof t=="boolean"}Co.exports=Wm});var Bo=l((K2,Uo)=>{var{random:Km}=ie(),A=d(),Lm=T(),ko=p(),Ht=Xe(),Ro=_(),Ze=q(),ue=E(),Xt=N(),Hm=j(),zo=S(),Zt=G();function Xm(t,e,n){return Ro(e)?Zm(t,e,n):Qm(t,e,n)}function Zm(t,e,n){if(n=Xt(n)?0:n,A(Ro(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),A(Ze(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Zt(t.index,(s,o)=>e(t.get(s,null),t.get(o,null)));return t.get(r,null)}else{let r=Zt(t.columns,(s,o)=>e(t.get(null,s),t.get(null,o)));return t.get(null,r)}}function Qm(t,e,n){let r=t.copy(),s=Km().toString();return r=r.assign(s,r.index),Xt(e)&&(e=[s],n=[!0]),(Ze(e)||ue(e))&&(e=[e],(Ht(n)||ue(n))&&(n=[n])),A(ko(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),A(zo(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Xt(n)&&(n=Hm(0,e.length).map(()=>!0)),A(ko(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),A(zo(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),A(e.length===n.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(o=>{if(A(ue(o)||Ze(o),"Column references can either be column names (as strings) or column indices (as whole numbers)."),ue(o)){let i=r.columns.indexOf(o);return A(i>-1,`The column "${o}" does not exist!`),i}if(Ze(o))return A(parseInt(o)===o,"Column indices must be whole numbers!"),A(o>=0,`The column index ${o} is out of bounds!`),A(o<r.columns.length,`The index ${o} is out of bounds!`),o}),n=n.map(o=>{if(A(ue(o)||Ht(o),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),ue(o)){let i=o.trim().toLowerCase();return A(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Ht(o))return o}),r.values=Zt(r.values,(o,i)=>{let u=0;for(;o[e[u]]===i[e[u]]&&u<e.length;)u++;let a=n[u];if(o[e[u]]===i[e[u]])return 0;if(o[e[u]]<i[e[u]])return a?-1:1;if(o[e[u]]>i[e[u]])return a?1:-1}),r.index=Lm(r.get(null,s).values),r=r.dropColumns(s),r}Uo.exports=Xm});var Qt=l((L2,Po)=>{function ep(t,e){return JSON.stringify(t.toObject(e))}Po.exports=ep});var Vo=l((H2,tn)=>{var en=ne(),tp=Qt();function np(t,e,n){let r=tp(t,n),s=!1,o=!1,i,u;try{let a=e;if(e.includes("/")){let f=e.split("/");a=f[f.length-1]}let c=document.createElement("a");c.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,c.download=a,c.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=Nr("fs"),c=Nr("path");a.writeFileSync(c.resolve(e),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new en(i):typeof tn<"u"?new en(u):new en("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return t}tn.exports=np});var Yo=l((X2,Jo)=>{var rp=d(),sp=N();function op(t,e){sp(e)?e=0:rp(e===0||e===1,"The axis parameter of the `toObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return e===0?t.index.forEach((r,s)=>{let o={};t.columns.forEach((i,u)=>{o[i]=t.values[s][u]}),n[r]=o}):t.columns.forEach((r,s)=>{let o={};t.index.forEach((i,u)=>{o[i]=t.values[u][s]}),n[r]=o}),n}Jo.exports=op});var ee=l((Z2,Wo)=>{var $o=d(),ip=p(),up=b(),ap=y(),cp=$(),Go=ve(),lp=S();function fp(t){if(up(t)||ap(t))return t.transpose();$o(ip(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=lp(t);if($o(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return Go(t);if(e.length===2){let n=cp(Go(e));for(let r=0;r<e[0];r++)for(let s=0;s<e[1];s++)n[s][r]=t[r][s];return n}}Wo.exports=fp});var Xo=l((Q2,Ho)=>{var Ko=d(),hp=p(),dp=b(),mp=Pe(),pp=y(),gp=S();function Lo(t,e,n){if(pp(n))return new t(e.values.concat(n.values));if(hp(n)){let r=gp(n);Ko(r.length===1&&!mp(r),"Only vectors can be appended to Series!");let s=e.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(e.values.length+i))}),s}return Ko(!dp(n),"DataFrames cannot be appended to Series!"),Lo(e,[n])}Ho.exports=Lo});var Qo=l((ex,Zo)=>{var qp=d(),yp=_();function bp(t,e){qp(yp(e),"The parameter to the `apply` method must be a function.");let n=t.copy();return n._values=n._values.map((r,s)=>e(r,s)),n}Zo.exports=bp});var ti=l((tx,ei)=>{var Np=N();function wp(t){let e=t.copy(),n=[];return e._values=e.values.filter((r,s)=>Np(r)?!1:(n.push(e.index[s]),!0)),e._index=n,e}ei.exports=wp});var ri=l((nx,ni)=>{var vp=q();function Sp(t,e){let n=[],r=[];e.values.forEach((o,i)=>{vp(o)&&(r.push(o),n.push(e.index[i]))});let s=new t(r);return s.name=e.name,s.index=n,s}ni.exports=Sp});var oi=l((rx,si)=>{var{copy:xp}=z();function Tp(t,e,n){let r=e.copy(),s=xp(r.index),o=[],i=r.values.filter((u,a)=>{let c=n(u,a,r.values);return c||o.push(r.index[a]),c});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new t,r.name=e.name,r):(r.values=i,r.index=s,r)}si.exports=Tp});var ui=l((sx,ii)=>{var L=d(),Op=q(),Dp=E(),Fp=N(),Ip=k();function _p(t,e){(Dp(e)||Op(e))&&(e=[e]);let n=Ip((e||[]).map(r=>typeof r));return L(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&L(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(L(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),L(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Fp(e)||(e=e.map(r=>{if(typeof r=="string")return L(t.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return L(r>=0,`Index ${r} is out of bounds!`),L(parseInt(r)===r,"Indices must be integers!"),L(r<t.index.length,`Index ${r} is out of bounds!`),t.index[r]})),t.getSubsetByNames(e)}ii.exports=_p});var ci=l((ox,ai)=>{var Fe=d(),Ep=p(),Ap=N(),jp=Se(),Mp=j(),Cp=S();function kp(t,e){let n=t.shape;Ap(e)&&(e=Mp(0,n[0])),Fe(Ep(e),"The `indices` array must be 1-dimensional array of whole numbers."),Fe(Cp(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(e.length>0,"The `indices` array must contain at least one index."),e.forEach(s=>{Fe(jp(s),"The `indices` array must be a 1-dimensional array of whole numbers."),Fe(s<t.index.length,`The row index ${s} is out of bounds.`)});let r=e.map(s=>t.index[s]);return t.getSubsetByNames(r)}ai.exports=kp});var fi=l((ix,li)=>{var Ie=d(),zp=p(),Rp=E(),Up=N(),Bp=S();function Pp(t,e,n){Up(n)&&(n=e.index),Ie(zp(n),"The `indices` array must be a 1-dimensional array of strings."),Ie(Bp(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),Ie(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{Ie(Rp(o),"The `indices` array must contain only strings."),Ie(e.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>e.values[e.index.indexOf(o)]);if(r.length===1)return r[0];let s=new t(r);return s.index=n,s.name=e.name,s}li.exports=Pp});var mi=l((ux,di)=>{var{copy:Vp}=z(),hi=j();function Jp(t){let e=t.copy(),n=typeof window>"u"?20:10;if(e.index.length>n){e=e.get(hi(0,n/2).concat(hi(e.index.length-n/2,e.index.length)));let s=Vp(e.index);s.splice(parseInt(s.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(s)}let r={};return e.values.forEach((s,o)=>{let i={};i[e.name]=s,r[e.index[o]]=i}),console.table(r),console.log("Shape:",t.shape,`
`),t}di.exports=Jp});var gi=l((ax,pi)=>{var Yp=He();function $p(t){let e=t.copy();return e.get(Yp(e.index))}pi.exports=$p});var yi=l((cx,qi)=>{var Gp=d(),Wp=_(),Kp=N(),Lp=G(),Hp=ee();function Xp(t,e,n){n=n||((a,c)=>a<c?-1:1),Gp(Kp(n)||Wp(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Hp([e.values,e.index]),s=Lp(r,(a,c)=>n(a[0],c[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new t;return u._values=o,u._index=i,u.name=e.name,u}qi.exports=Xp});var wi=l((lx,Ni)=>{var Zp=G(),bi=ee();function Qp(t,e){let n=bi([e.values,e.index]);n=bi(Zp(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new t(n[0]);return r.index=n[1],r.name=e.name,r}Ni.exports=Qp});var Si=l((fx,vi)=>{function eg(t){let e={};return e[t.name]={},t.index.forEach((n,r)=>{e[t.name][n]=t.values[r]}),e}vi.exports=eg});var Fi=l((hx,Di)=>{var{copy:Qe}=z(),P=d(),nn=p(),tg=E(),ng=N(),xi=Ke(),Ti=j(),et=ve(),rg=Xo(),sg=Qo(),og=ti(),ig=ri(),ug=oi(),ag=ui(),cg=ci(),lg=fi(),fg=mi(),hg=gi(),dg=yi(),mg=wi(),pg=Si(),_e=S(),gg=ee(),Oi=Symbol.for("@jrc03c/js-math-tools/series");Di.exports=function(t){class e{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Oi}catch{return!1}}constructor(r){let s=this;if(s.name="data",Object.defineProperty(s,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Oi}),Object.defineProperty(s,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"values",{configurable:!0,enumerable:!0,get(){return s._values},set(o){P(nn(o),"The new values must be a 1-dimensional array!");let i=_e(o);P(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<s._index.length?s._index=s._index.slice(0,i[0]):i[0]>s._index.length&&(s._index=s._index.concat(Ti(s._index.length,i[0]).map(u=>"item"+xi(u,(o.length-1).toString().length)))),s._values=o}}),Object.defineProperty(s,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(s,"index",{configurable:!0,enumerable:!0,get(){return s._index},set(o){P(nn(o),"The new index must be a 1-dimensional array of strings!"),P(o.length===s.shape[0],"The new index must be the same length as the old index!"),P(_e(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{P(tg(i),"All of the row names must be strings!")}),s._index=o}}),r){if(r instanceof e)s.name=r.name,s.values=Qe(r.values),s.index=Qe(r.index);else if(nn(r)){let o=_e(r);P(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),s.values=r}else if(r instanceof Object){let o=Object.keys(r);P(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],u=r[i];P(_e(u).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),s.name=i,s.values=u.slice()}}}get shape(){return _e(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(s=>!ng(s)).length===0}clear(){let s=this.copy();return s.values.forEach((o,i)=>{s.values[i]=void 0}),s}get(r){return ag(this,r)}getSubsetByNames(r){return lg(e,this,r)}getSubsetByIndices(r){return cg(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=this,s=new e(et(r.values));return s.index=et(r.index),s.name=r.name,s}resetIndex(){let r=this,s=r.copy();return s.index=Ti(0,r.shape[0]).map(o=>"item"+xi(o,(s.index.length-1).toString().length)),s}copy(){let r=this,s=new e;return s._values=Qe(r.values),s._index=Qe(r.index),s.name=r.name,s}append(r){return rg(e,this,r)}apply(r){return sg(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return og(this,r,s)}dropNaN(){return ig(e,this)}toObject(){return pg(this)}print(){return fg(this)}shuffle(){return hg(this)}sort(r){return dg(e,this,r)}sortByIndex(){return mg(e,this)}filter(r){return ug(e,this,r)}toDataFrame(){let r=this,s=new t(gg([r.values]));return s.columns=[r.name],s.index=r.index,s}transpose(){let s=this.copy();return s.values=et(s.values),s.index=et(s.index),s}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}});var Ae=l((dx,Mi)=>{var{copy:rn}=z(),R=d(),Ii=Ne(),qg=ms(),yg=bs(),bg=Ss(),Ng=Ts(),wg=As(),vg=Cs(),Sg=Us(),xg=Js(),Tg=Gs(),_i=Zs(),Og=io(),Dg=fo(),Fg=mo(),Ig=qo(),_g=Mo(),Eg=Bo(),Ag=Vo(),jg=Qt(),Mg=Yo(),Cg=T(),Ee=p(),kg=Y(),Ei=N(),sn=Ke(),zg=$(),on=j(),ae=S(),Ai=ee(),ji=Symbol.for("@jrc03c/js-math-tools/dataframe");function tt(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<t;r++)n+=e[parseInt(Math.random()*e.length)];return n}var D=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===ji}catch{return!1}}constructor(e){let n=this;if(Object.defineProperty(n,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:ji}),Object.defineProperty(n,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"values",{configurable:!0,enumerable:!0,get(){return n._values.length===0||!Ei(n._values[0])&&n._values[0].length===0?[[]]:n._values},set(r){R(Ee(r),"The new values must be a 2-dimensional array!");let s=ae(r);R(s.length===2,"The new array of values must be 2-dimensional!"),s[0]<n._index.length?n._index=n._index.slice(0,s[0]):s[0]>n._index.length&&(n._index=n._index.concat(on(n._index.length,s[0]).map(o=>"row"+sn(o,(s[0]-1).toString().length)))),s[1]<n._columns.length?n._columns=n._columns.slice(0,s[1]):s[1]>n._columns.length&&(n._columns=n._columns.concat(on(n._columns.length,s[1]).map(o=>"col"+sn(o,(s[1]-1).toString().length)))),n._values=r}}),Object.defineProperty(n,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"columns",{configurable:!0,enumerable:!0,get(){return n._columns},set(r){R(Ee(r),"The new columns list must be a 1-dimensional array of strings!"),R(n.isEmpty||r.length===n.shape[1],"The new columns list must be the same length as the old columns list!"),R(ae(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+tt(8):o.trim()));let s=(()=>{let o=Ii(r),i={};return o.forEach(u=>{i[u.value]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+tt(8):o),n._columns=r}}),Object.defineProperty(n,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(n,"index",{configurable:!0,enumerable:!0,get(){return n._index},set(r){R(Ee(r),"The new index must be a 1-dimensional array of strings!"),R(n.isEmpty||r.length===n.shape[0],"The new index must be the same length as the old index!"),R(ae(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+tt(8):o.trim()));let s=(()=>{let o=Ii(r),i={};return o.forEach(u=>{i[u.value]=u.count}),i})();r=r.map(o=>s[o]>1?o+"_"+tt(8):o),n._index=r}}),R(Ei(e)||kg(e)||Ee(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof D)n.values=rn(e.values),n.columns=rn(e.columns),n.index=rn(e.index);else if(Ee(e)){let r=ae(e);R(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),n.values=e}else{n._columns=Object.keys(e);let r=[];n._columns.forEach(o=>{let i=e[o];r.push(i)}),n._values=Ai(r);let s=ae(n.values);n._index=on(0,s[0]).map(o=>"row"+sn(o,(s[0]-1).toString().length))}}get shape(){return ae(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){let n=this;n.index=e}get isEmpty(){return Cg(this.values).length===0}clear(){let e=this,n=new D(zg(e.shape));return n.columns=e.columns.slice(),n.index=e.index.slice(),n}get(e,n){let r=this;if(arguments.length===0)return r;if(arguments.length===1)try{return r.get(null,e)}catch{return r.get(e,null)}return Tg(r,e,n)}getSubsetByNames(e,n){return Dg(D,H,this,e,n)}getSubsetByIndices(e,n){return Og(this,e,n)}getDummies(e){return _i(D,this,e)}oneHotEncode(e){return _i(D,this,e)}transpose(){let e=this,n=new D(Ai(e.values));return n.columns=e.index.slice(),n.index=e.columns.slice(),n}get T(){return this.transpose()}resetIndex(e){return Ig(this,e)}copy(){return Ng(D,this)}assign(e,n){return bg(D,H,this,e,n)}apply(e,n){return yg(D,H,this,e,n)}dropMissing(e,n,r){return vg(D,H,this,e,n,r)}dropNaN(e,n,r){return Sg(D,this,e,n,r)}drop(e,n){return wg(D,H,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toObject(e){return Mg(this,e)}toJSONString(e){return jg(this,e)}saveAsJSON(e,n){return Ag(this,e,n)}print(){return Fg(D,H,this)}sort(e,n){return Eg(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return xg(D,H,this,e,n)}shuffle(e){return _g(this,e)}append(e,n){return qg(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){let e=this;return JSON.stringify(e)}},H=Fi()(D);Mi.exports={DataFrame:D,Series:H}});var ce=l((mx,ki)=>{var Rg=d(),Ug=T(),Bg=p(),Pg=b(),Vg=y();function Ci(t){if(Pg(t)||Vg(t))return Ci(t.values);Rg(Bg(t),"The `max` function only works on arrays, Series, and DataFrames!");try{return Math.max(...Ug(t))}catch{return NaN}}ki.exports=Ci});var w=l((px,Pi)=>{var{DataFrame:zi,Series:Ri}=Ae(),Ui=d(),je=p(),un=b(),Bi=C(),Jg=_(),an=y(),Yg=ce(),$g=j(),nt=S();function Gg(t){return je(t)||an(t)||un(t)}function Wg(t){return Ui(Jg(t),"You must pass a function into the `vectorize` function!"),function e(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return je(a)?!0:an(a)?(n=!0,s.push(a),!0):un(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{Ui(Bi(je(u)?nt(u):u.shape,je(i[a+1])?nt(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Yg(i.map(c=>c.length?c.length:c.values.length)),a=$g(0,u).map(c=>{let f=Object.keys(arguments).map(h=>{if(Gg(arguments[h])){if(je(arguments[h]))return arguments[h][c];if(an(arguments[h]))return arguments[h].values[c];if(un(arguments[h]))return arguments[h].values[c]}else return arguments[h]});return e(...f)});if(r)try{if(o.length===1&&Bi(nt(o[0]),nt(a))){let c=new zi(a);return c.index=o[0].index.slice(),c.columns=o[0].columns.slice(),c}else return new zi(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let c=new Ri(a);return c.name=s[0].name,c.index=s[0].index.slice(),c}else return new Ri(a)}catch{return a}return a}else return t(...arguments)}}Pi.exports=Wg});var rt=l((gx,Vi)=>{var Kg=q(),Lg=w();function Hg(t){try{return Kg(t)?Math.abs(t):NaN}catch{return NaN}}Vi.exports=Lg(Hg)});var st=l((qx,Ji)=>{var Xg=q(),Zg=w();function Qg(){try{let t=0,e=Object.values(arguments);for(let n=0;n<e.length;n++){if(!Xg(e[n]))return NaN;t+=e[n]}return t}catch{return NaN}}Ji.exports=Zg(Qg)});var Me=l((yx,Yi)=>{var eq=w();function tq(t,e){try{return e(t)}catch{return NaN}}Yi.exports=eq(tq)});var Gi=l((bx,$i)=>{var nq=q(),rq=w();function sq(t){try{return nq(t)?Math.acos(t):NaN}catch{return NaN}}$i.exports=rq(sq)});var Ki=l((Nx,Wi)=>{var oq=q(),iq=w();function uq(t){try{return oq(t)?Math.asin(t):NaN}catch{return NaN}}Wi.exports=iq(uq)});var Hi=l((wx,Li)=>{var aq=q(),cq=w();function lq(t){try{return aq(t)?Math.atan(t):NaN}catch{return NaN}}Li.exports=cq(lq)});var Zi=l((vx,Xi)=>{var fq=d(),hq=ye(),dq=p(),mq=b(),pq=y(),gq=ce();function cn(t){if(mq(t)){let e=cn(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(pq(t)){let e=cn(t.values);return[t.index[e]]}fq(dq(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let e=hq(t,gq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}Xi.exports=cn});var ot=l((Sx,eu)=>{var qq=d(),yq=T(),bq=p(),Nq=b(),wq=y();function Qi(t){if(Nq(t)||wq(t))return Qi(t.values);qq(bq(t),"The `min` function only works on arrays, Series, and DataFrames!");try{return Math.min(...yq(t))}catch{return NaN}}eu.exports=Qi});var nu=l((xx,tu)=>{var vq=d(),Sq=ye(),xq=p(),Tq=b(),Oq=y(),Dq=ot();function ln(t){if(Tq(t)){let e=ln(t.values);return[t.index[e[0]],t.columns[e[1]]]}if(Oq(t)){let e=ln(t.values);return[t.index[e]]}vq(xq(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let e=Sq(t,Dq(t));return e?e.length===0?void 0:e.length===1?e[0]:e:void 0}catch{return}}tu.exports=ln});var dn=l((Tx,ou)=>{var ru=p(),fn=Xe(),Fq=b(),Iq=C(),su=q(),_q=Y(),Eq=y(),hn=N();function V(t,e){if(Fq(t)||Eq(t))return t.apply(n=>V(n,e));if(ru(t))return t.map(n=>V(n,e));if(e==="null")return null;if(e==="number"){if(hn(t))return NaN;let n=V(t,"boolean");if(fn(n))return n?1:0;try{JSON.parse(t)}catch{let o=V(t,"date");if(o instanceof Date)return o.getTime()}let r=parseFloat(t);return isNaN(r)?NaN:r}if(e==="boolean"){if(fn(t))return t;if(su(t))return t===0?!1:t===1?!0:null;try{let n=(typeof t=="object"?t.toString()==="null"?"false":JSON.stringify(t):t.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(e==="date"){if(t instanceof Date)return t;if(hn(t))return null;let n=parseFloat(t);if(!isNaN(n)){let s=new Date(t);return s.toString()==="Invalid Date"?null:s}let r=Date.parse(t);return isNaN(r)?null:new Date(r)}if(e==="object"){if(_q(t))return t;let n=V(t,"boolean");if(fn(n))return null;try{let s=V(t,"number");if(su(s))return JSON.parse(t),null}catch{}let r=V(t,"date");if(r)return r;try{let s=JSON.parse(t);return ru(s)?s.map(o=>V(o,e)):s}catch{return null}}if(e==="string")return hn(t)?Iq(t,void 0)?"undefined":"null":t instanceof Date?t.toJSON():(()=>typeof t=="object"?t===null?"null":JSON.stringify(t):t.toString())()}ou.exports=V});var uu=l((Ox,iu)=>{var Aq=q(),jq=w();function Mq(t){try{return Aq(t)?Math.ceil(t):NaN}catch{return NaN}}iu.exports=jq(Mq)});var lu=l((Dx,cu)=>{var Cq=rt(),au=q(),kq=N(),zq=w();function Rq(t,e){try{if(!au(t))return NaN;if(kq(e))e=1e-10;else if(!au(e))return NaN;return Cq(t)<e?0:t}catch{return NaN}}cu.exports=zq(Rq)});var hu=l((Fx,fu)=>{var mn=q(),Uq=w();function Bq(t,e,n){try{return mn(t)?mn(e)?mn(n)?t<e?e:t>n?n:t:NaN:NaN:NaN}catch{return NaN}}fu.exports=Uq(Bq)});var mu=l((Ix,du)=>{var pn=d(),Pq=T(),Vq=p(),Jq=b(),Yq=q(),$q=y();function gn(t,e){if(Jq(t)||$q(t))return gn(t.values,e);if(pn(Vq(t),"The `combinations` function only works on arrays, Series, and DataFrames!"),pn(Yq(e),"`r` must be a whole number!"),t=Pq(t),e>t.length)return[t];if(e<=0)return[[]];if(pn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(s+1);if(o.length<e-1)return;gn(o,e-1).forEach(u=>{n.push([r].concat(u))})}),n}du.exports=gn});var it=l((_x,gu)=>{var Gq=d(),Wq=T(),Kq=p(),Lq=b(),Hq=y();function pu(t){if(Lq(t)||Hq(t))return pu(t.values);Gq(Kq(t),"The `mean` function only works on arrays, Series, and DataFrames!");try{let e=Wq(t),n=0;return e.forEach(r=>{n+=r}),n/e.length}catch{return NaN}}gu.exports=pu});var yn=l((Ex,vu)=>{var qu=d(),yu=p(),ut=q(),bu=y(),Nu=it(),wu=S();function qn(t,e){if(bu(t))return qn(t.values,e);if(bu(e))return qn(t,e.values);qu(yu(t)&&yu(e)&&wu(t).length===1&&wu(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),qu(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!");try{let n=Nu(t),r=Nu(e);if(!ut(n)||!ut(r))return NaN;let s=Math.max(t.length,e.length),o=0;for(let i=0;i<s;i++){if(!ut(t[i]))return NaN;if(!ut(e[i]))return NaN;o+=(t[i]-n)*(e[i]-r)}return o/t.length}catch{return NaN}}vu.exports=qn});var at=l((Ax,Su)=>{var Xq=q(),Zq=w();function Qq(t){try{return Xq(t)?Math.sqrt(t):NaN}catch{return NaN}}Su.exports=Zq(Qq)});var bn=l((jx,Tu)=>{var ey=d(),ty=T(),ny=p(),ry=b(),sy=q(),oy=y(),iy=it();function xu(t){if(ry(t)||oy(t))return xu(t.values);ey(ny(t),"The `variance` function only works on arrays, Series, and DataFrames!");try{let e=ty(t),n=iy(e),r=0;for(let s=0;s<e.length;s++){if(!sy(e[s]))return NaN;r+=(e[s]-n)*(e[s]-n)}return r/e.length}catch{return NaN}}Tu.exports=xu});var ct=l((Mx,Du)=>{var uy=d(),ay=p(),cy=b(),ly=y(),fy=at(),hy=bn();function Ou(t){if(cy(t)||ly(t))return Ou(t.values);uy(ay(t),"The `std` function only works on arrays, Series, and DataFrames!");try{return fy(hy(t))}catch{return NaN}}Du.exports=Ou});var Mu=l((Cx,ju)=>{var Fu=d(),dy=yn(),Iu=p(),_u=y(),Eu=S(),Au=ct();function Nn(t,e){if(_u(t))return Nn(t.values,e);if(_u(e))return Nn(t,e.values);Fu(Iu(t)&&Iu(e)&&Eu(t).length===1&&Eu(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),Fu(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{return dy(t,e)/(Au(t)*Au(e))}catch{return NaN}}ju.exports=Nn});var ku=l((kx,Cu)=>{var my=q(),py=w();function gy(t){try{return my(t)?Math.cos(t):NaN}catch{return NaN}}Cu.exports=py(gy)});var Ru=l((zx,zu)=>{zu.exports=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"})});var Yu=l((Rx,Ju)=>{var qy=d(),Uu=p(),Bu=b(),yy=C(),Pu=y(),Vu=k();function wn(t,e){if(Bu(t)||Pu(t))return wn(t.values,e);if(Bu(e)||Pu(e))return wn(t,e.values);qy(Uu(t)&&Uu(e),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Vu(t),r=Vu(e),s=[];return n.forEach(o=>{r.findIndex(i=>yy(i,o))<0&&s.push(o)}),s}Ju.exports=wn});var lt=l((Ux,Gu)=>{var $u=q(),by=w();function Ny(t,e){try{return $u(t)?$u(e)?Math.pow(t,e):NaN:NaN}catch{return NaN}}Gu.exports=by(Ny)});var vn=l((Bx,Wu)=>{var wy=q(),vy=w();function Sy(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=1;for(let n=0;n<t.length;n++){if(!wy(t[n]))return NaN;e*=t[n]}return e}catch{return NaN}}Wu.exports=vy(Sy)});var le=l((Px,Ku)=>{var xy=vn();function Ty(){return xy(...arguments)}Ku.exports=Ty});var Sn=l((Vx,Lu)=>{var Oy=st(),Dy=le();function Fy(t,e){return Oy(t,Dy(e,-1))}Lu.exports=Fy});var ft=l((Jx,Xu)=>{var Iy=d(),_y=T(),Ey=p(),Ay=b(),jy=y();function Hu(t){if(Ay(t)||jy(t))return Hu(t.values);Iy(Ey(t),"The `sum` function only works on arrays, Series, and DataFrames!");try{return t.length===0?NaN:_y(t).reduce((e,n)=>e+n,0)}catch{return NaN}}Xu.exports=Hu});var sa=l((Yx,ra)=>{var My=rt(),Cy=d(),Zu=p(),Qu=b(),ky=C(),ea=q(),ta=y(),zy=lt(),na=S(),Ry=at(),Uy=Sn(),By=ft();function xn(t,e){if(ea(t)&&ea(e))return My(t-e);if(Qu(t)||ta(t))return xn(t.values,e);if(Qu(e)||ta(e))return xn(t,e.values);Zu(t)&&Zu(e)&&Cy(ky(na(t),na(e)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ry(By(zy(Uy(t,e),2)))}catch{return NaN}}ra.exports=xn});var ia=l(($x,oa)=>{var Py=lt(),Vy=le();function Jy(t,e){return Vy(t,Py(e,-1))}oa.exports=Jy});var On=l((Gx,ha)=>{var{DataFrame:ua,Series:aa}=Ae(),ht=d(),ca=T(),la=p(),Tn=b(),Yy=q(),dt=y(),$y=le(),mt=S(),Gy=ft(),fa=ee();function X(t,e){if(Tn(t)){let s=X(t.values,e);if(mt(s).length===1){let o=new aa(s);return o.name=dt(e)?e.name:o.name,o.index=t.index.slice(),o}else{let o=new ua(s);return o.index=t.index.slice(),Tn(e)&&(o.columns=e.columns.slice()),o}}if(Tn(e)){let s=X(t,e.values);if(mt(s).length===1){let o=new aa(s);return o.name=dt(t)?t.name:o.name,o.index=e.columns.slice(),o}else{let o=new ua(s);return o.columns=e.columns.slice(),o}}if(dt(t))return X(t.values,e);if(dt(e))return X(t,e.values);ht(la(t)&&la(e),"The `dot` function only works on arrays, Series, and DataFrames!"),ca(t).concat(ca(e)).forEach(s=>{ht(Yy(s),"One of the arrays you passed into the `dot` function contains non-numerical values!")});let n=mt(t),r=mt(e);if(ht(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),ht(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Gy($y(t,e));if(n.length===1&&r.length===2)return fa(e).map(s=>X(t,s));if(n.length===2&&r.length===1)return t.map(s=>X(s,e));if(n.length===2&&r.length===2){let s=fa(e),o=[];for(let i=0;i<t.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(X(t[i],s[a]));o.push(u)}return o}}ha.exports=X});var Dn=l((Wx,ma)=>{var Wy=d(),Ky=p(),Ly=b(),Hy=y(),Xy=N();function da(t){if(Ly(t)||Hy(t))return t.dropMissing(...Object.values(arguments).slice(1));Wy(Ky(t),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(n=>{try{return e.push(da(n))}catch{Xy(n)||e.push(n)}}),e}ma.exports=da});var va=l((Kx,wa)=>{var pa=d(),ga=p(),qa=b(),Zy=C(),ya=y(),ba=N(),Na=S();function pt(t,e){if(qa(t)||ya(t))return pt(t.values,e);if(qa(e)||ya(e))return pt(t,e.values);pa(ga(t)&&ga(e),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),pa(Zy(Na(t),Na(e)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=pt(t[s],e[s]);n.push(o),r.push(i)}catch{!ba(t[s])&&!ba(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}wa.exports=pt});var _a=l((Lx,Ia)=>{var Sa=d(),xa=p(),Ta=b(),Qy=C(),Oa=q(),Da=y(),Fa=S();function gt(t,e){if(Ta(t)||Da(t))return gt(t.values,e);if(Ta(e)||Da(e))return gt(t,e.values);Sa(xa(t)&&xa(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),Sa(Qy(Fa(t),Fa(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<t.length;s++)try{let[o,i]=gt(t[s],e[s]);n.push(o),r.push(i)}catch{Oa(t[s])&&Oa(e[s])&&(n.push(t[s]),r.push(e[s]))}return[n,r]}Ia.exports=gt});var Aa=l((Hx,Ea)=>{var e1=Dn();function t1(t){return e1(t)}Ea.exports=t1});var Ma=l((Xx,ja)=>{var n1=q(),r1=w();function s1(t){try{return n1(t)?Math.exp(t):NaN}catch{return NaN}}ja.exports=r1(s1)});var za=l((Zx,ka)=>{var o1=w();function Ca(t){try{return t!==parseInt(t)?NaN:t<=1?1:t*Ca(t-1)}catch{return NaN}}ka.exports=o1(Ca)});var Pa=l((Qx,Ba)=>{var i1=d(),u1=T(),Ra=p(),a1=b(),c1=_(),Ua=Y(),l1=y();function Fn(t,e){if(a1(t))return Fn(u1(t.values),e);if(l1(t))return Fn(t.values,e);if(i1(Ua(t)||Ra(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!c1(e)){let s=e;e=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Ua(s)){i.push(s);let u=Object.keys(s);for(let a=0;a<u.length;a++){let c=u[a],f=s[c];if(o(f))return f;let h=n(f,o,i);if(h)return h}}else if(Ra(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let c=n(a,o,i);if(c)return c}}else if(o(s))return s;return null}function r(s){try{return e(s)}catch{return!1}}return n(t,r)}Ba.exports=Fn});var $a=l((e3,Ya)=>{var f1=d(),h1=T(),Va=p(),d1=b(),m1=_(),Ja=Y(),p1=y();function In(t,e){if(d1(t))return In(h1(t.values),e);if(p1(t))return In(t.values,e);if(f1(Ja(t)||Va(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!m1(e)){let o=e;e=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Ja(o)){u.push(o);let a=Object.keys(o),c=[];for(let f=0;f<a.length;f++){let h=a[f],m=o[h],g=!1;i(m)&&(c.push(m),g=!0);let F=n(m,i,u);F&&F.length>0&&F.slice(g?1:0).forEach(O=>c.push(O))}return c}else if(Va(o)){u.push(o);let a=[];for(let c=0;c<o.length;c++){let f=o[c],h=!1;i(f)&&(a.push(f),h=!0);let m=n(f,i,u);m&&m.length>0&&m.slice(h?1:0).forEach(g=>a.push(g))}return a}else if(i(o))return[o];return null}function r(o){try{return e(o)}catch{return!1}}let s=n(t,r);return s&&s.length>0?s:null}Ya.exports=In});var Wa=l((t3,Ga)=>{var g1=q(),q1=w();function y1(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return g1(e)?e:NaN}catch{return NaN}}Ga.exports=q1(y1)});var La=l((n3,Ka)=>{var b1=q(),N1=w();function w1(t){try{return b1(t)?Math.floor(t):NaN}catch{return NaN}}Ka.exports=N1(w1)});var _n=l((r3,Ha)=>{var v1=q(),S1=Oe(),x1=Le();function T1(t){v1(t)&&(t=[t]);let e=[],n=S1(t);for(let r=0;r<n;r++)e.push(0);return x1(e,t)}Ha.exports=T1});var Za=l((s3,Xa)=>{var qt=d(),O1=q(),D1=N(),F1=_n();function I1(t){qt(!D1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),qt(O1(t),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),qt(parseInt(t)===t,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),qt(t>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let e=F1([t,t]);for(let n=0;n<t;n++)e[n][n]=1;return e}Xa.exports=I1});var ec=l((o3,Qa)=>{Qa.exports=["true","false","yes","no"]});var nc=l((i3,tc)=>{tc.exports=["null","none","nan","na","n/a","","undefined"]});var ic=l((u3,oc)=>{var _1=Me(),E1=d(),A1=ec(),j1=dn(),M1=Ne(),rc=T(),En=p(),C1=b(),sc=q(),k1=y(),z1=E(),R1=nc();function yt(t){return t.type==="number"&&(typeof t.value<"u"?t.isInteger=parseInt(t.value)===t.value:t.isInteger=rc(t.values).every(e=>sc(e)?parseInt(e)===e:!0)),t}function bt(t){if(C1(t)){let s=t.copy(),o=bt(t.values);return s.values=o.values,yt({type:o.type,values:s})}if(k1(t)){let s=t.copy(),o=bt(t.values);return s.values=o.values,yt({type:o.type,values:s})}if(!En(t)){let s=bt([t]);return s.value=s.values[0],delete s.values,yt(s)}E1(En(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=rc(t).map(s=>{if(s===void 0)return"null";try{if(typeof s=="object"){let u=new Date(s.toString());if(u instanceof Date&&u.toString()!=="Invalid Date")return"date"}}catch{}z1(s)||(s=JSON.stringify(s));let i=s.toLowerCase().trim();if(R1.indexOf(i)>-1)return"null";if(A1.indexOf(i)>-1)return"boolean";try{let u=JSON.parse(s);return sc(u)?"number":typeof u=="object"?En(u)?"string":"object":"string"}catch{return new Date(s).toString()!=="Invalid Date"?"date":"string"}}),r=M1(e).sort((s,o)=>o.count-s.count)[0].value;return yt({type:r,values:_1(t,s=>j1(s,r))})}oc.exports=bt});var ac=l((a3,uc)=>{var U1=q(),B1=w();function P1(t){try{let e=JSON.parse(t);return U1(e)?parseInt(e):NaN}catch{return NaN}}uc.exports=B1(P1)});var lc=l((c3,cc)=>{var V1=d(),J1=p(),Y1=b(),$1=C(),G1=y(),An=k();function W1(){let t=Object.values(arguments).map(n=>Y1(n)||G1(n)?An(n.values):(V1(J1(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),An(n)));return An(t).filter(n=>t.every(r=>r.findIndex(s=>$1(s,n))>-1))}cc.exports=W1});var mc=l((l3,dc)=>{var fc=st(),Z=d(),K1=On(),L1=T(),H1=p(),X1=b(),jn=q(),hc=le(),Z1=S();function Nt(t){if(X1(t)){let n=t.copy();return n.values=Nt(n.values),n}Z(H1(t),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!"),L1(t).forEach(n=>Z(jn(n),"The array passed into the `inverse` function must contain only numbers!"));let e=Z1(t);if(Z(e.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),Z(e[0]===e[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),Z(e[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),e[0]===0)return t;if(e[0]===1)return Z(t[0][0]!==0,"This matrix cannot be inverted!"),1/t[0][0];if(e[0]===2){let n=t[0][0],r=t[0][1],s=t[1][0],o=t[1][1],i=n*o-r*s;Z(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return hc(u,1/i)}else if(e[0]>1){let n=(r,s)=>jn(r)||jn(s)?hc(r,s):K1(r,s);for(let r=1;r<e[0]-1;r++)try{let s=t.slice(0,r).map(O=>O.slice(0,r)),o=t.slice(0,r).map(O=>O.slice(r,e[0])),i=t.slice(r,e[0]).map(O=>O.slice(0,r)),u=t.slice(r,e[0]).map(O=>O.slice(r,e[0])),a=Nt(s),c=Nt(fc(u,n(-1,n(n(i,a),o)))),f=fc(a,n(n(n(n(a,o),c),i),a)),h=n(-1,n(n(a,o),c)),m=n(-1,n(n(c,i),a)),g=c;return f.map((O,B)=>O.concat(h[B])).concat(m.map((O,B)=>O.concat(g[B])))}catch{}Z(!1,"This matrix cannot be inverted!")}}dc.exports=Nt});var gc=l((f3,pc)=>{var Q1=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);pc.exports=Q1});var yc=l((h3,qc)=>{var Mn=q(),eb=w();function tb(t,e,n){try{return Mn(t)?Mn(e)?Mn(n)?n*(e-t)+t:NaN:NaN:NaN}catch{return NaN}}qc.exports=eb(tb)});var wc=l((d3,Nc)=>{var bc=q(),nb=N(),rb=w();function sb(t,e){try{return e=nb(e)?Math.E:e,bc(t)?bc(e)?Math.log(t)/Math.log(e):NaN:NaN}catch{return NaN}}Nc.exports=rb(sb)});var xc=l((m3,Sc)=>{var ob=d(),ib=T(),ub=p(),ab=b(),cb=y(),lb=G();function vc(t){if(ab(t)||cb(t))return vc(t.values);ob(ub(t),"The `median` function only works on arrays, Series, and DataFrames!");try{let e=lb(ib(t));return e.length===0?NaN:e.length%2===0?(e[e.length/2-1]+e[e.length/2])/2:e[parseInt(e.length/2)]}catch{return NaN}}Sc.exports=vc});var Dc=l((p3,Oc)=>{var Tc=q(),fb=w();function hb(t,e){try{return Tc(t)?Tc(e)?t%e:NaN:NaN}catch{return NaN}}Oc.exports=fb(hb)});var Ec=l((g3,_c)=>{var db=d(),mb=Ne(),pb=T(),gb=p(),qb=b(),yb=y(),bb=k(),Fc=G();function Ic(t){if(qb(t)||yb(t))return Ic(t.values);db(gb(t),"The `mode` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let e=pb(t);if(e.length===0)return NaN;let n={},r=bb(e);r.forEach(u=>{n[u]=mb(e,u)});let s=Fc(r,(u,a)=>n[a]-n[u]),o=s[0];return Fc(s.filter(u=>n[u]===n[o]))}catch{return NaN}}_c.exports=Ic});var Cc=l((q3,Mc)=>{var{random:Ac}=ie(),Nb=Me(),wb=N(),vb=$();function jc(){let t=Ac(),e=Ac();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function Sb(t){return wb(t)?jc():Nb(vb(t),jc)}Mc.exports=Sb});var zc=l((y3,kc)=>{var xb=Me(),Tb=$();function Ob(t){return xb(Tb(t),()=>1)}kc.exports=Ob});var Uc=l((b3,Rc)=>{var Cn=d(),Db=T(),Fb=p(),Ib=b(),_b=q(),Eb=y(),Ab=N();function wt(t,e){if(Ib(t)||Eb(t))return wt(t.values,e);if(Cn(Fb(t),"The `permutations` function only works on arrays, Series, and DataFrames!"),Ab(e)&&(e=t.length),Cn(_b(e),"`r` must be a whole number!"),t=Db(t),e>t.length)return wt(t);if(e<=0)return[[]];if(Cn(e===parseInt(e),"`r` must be a whole number!"),t.length<2)return t;let n=[];return t.forEach((r,s)=>{let o=t.slice(0,s),i=t.slice(s+1),u=o.concat(i);wt(u,e-1).forEach(c=>{n.push([r].concat(c))})}),n}Rc.exports=wt});var Pc=l((N3,Bc)=>{var{DataFrame:jb,Series:Mb}=Ae(),Cb=p(),kb=b(),zb=we(),Rb=y(),Ub=S();function Bb(){Object.keys(arguments).forEach(t=>{let e=arguments[t];if(Cb(e))if(zb(e))console.log(e);else{let n=Ub(e);n.length===1?new Mb(e).print():n.length==2?new jb(e).print():console.log(e)}else kb(e)||Rb(e)?e.print():console.log(e)})}Bc.exports=Bb});var Yc=l((w3,Jc)=>{var Pb=p(),Vb=q(),Vc=N(),Jb=ce(),Yb=ot(),$b=w(),Gb=$b(function(t,e,n,r,s){try{return[t,e,n,r,s].every(o=>Vb(o))?n-e===0?NaN:(s-r)*(t-e)/(n-e)+r:NaN}catch{return NaN}});function Wb(t,e,n,r,s){return Pb(t)&&Vc(r)&&Vc(s)&&(r=e,s=n,e=Yb(t),n=Jb(t)),Gb(t,e,n,r,s)}Jc.exports=Wb});var Gc=l((v3,$c)=>{var Kb=q(),Lb=w();function Hb(t){try{return Kb(t)?Math.round(t):NaN}catch{return NaN}}$c.exports=Lb(Hb)});var Kc=l((S3,Wc)=>{var Xb=q(),Zb=w();function Qb(t){try{return Xb(t)?t<0?-1:t>0?1:0:NaN}catch{return NaN}}Wc.exports=Zb(Qb)});var Hc=l((x3,Lc)=>{var eN=q(),tN=w();function nN(t){try{return eN(t)?Math.sin(t):NaN}catch{return NaN}}Lc.exports=tN(nN)});var Zc=l((T3,Xc)=>{var rN=ct();function sN(t){return rN(t)}Xc.exports=sN});var el=l((O3,Qc)=>{var oN=q(),iN=w();function uN(t){try{return oN(t)?Math.tan(t):NaN}catch{return NaN}}Qc.exports=iN(uN)});var vt=l((D3,rl)=>{var tl=d(),nl=_();function aN(t,e){tl(nl(t),"`fn` must be a function!");let n=new Date;return e?t(...e):t(),new Date-n}async function cN(t,e){tl(nl(t),"`fn` must be a function!");let n=new Date;return e?await t(...e):await t(),new Date-n}rl.exports={timeSync:aN,timeAsync:cN}});var ol=l((F3,sl)=>{var lN=p(),fN=b(),hN=y(),dN=k();function mN(){return dN([...arguments].map(t=>lN(t)?t:fN(t)||hN(t)?t.values:[t]))}sl.exports=mN});var ul=l((I3,il)=>{var pN=d(),gN=p(),qN=b(),yN=y(),bN=N(),NN=ce(),wN=j();function vN(){let t=[],e=Object.values(arguments).map(n=>((qN(n)||yN(n))&&(n=n.values),pN(gN(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return wN(0,NN(e.map(n=>n.length))).forEach(n=>{let r=[];e.forEach(s=>{let o=s[n];r.push(bN(o)?void 0:o)}),t.push(r)}),t}il.exports=vN});var v=l((_3,kn)=>{var{copy:SN,decycle:xN}=z(),{DataFrame:TN,Series:ON}=Ae(),fe={abs:rt(),add:st(),apply:Me(),arccos:Gi(),arcsin:Ki(),arctan:Hi(),argmax:Zi(),argmin:nu(),assert:d(),cast:dn(),ceil:uu(),chop:lu(),clamp:hu(),combinations:mu(),copy:SN,correl:Mu(),cos:ku(),count:Ne(),covariance:yn(),DataFrame:TN,dataTypes:Ru(),decycle:xN,diff:Yu(),distance:sa(),divide:ia(),dot:On(),dropMissing:Dn(),dropMissingPairwise:va(),dropNaN:Gt(),dropNaNPairwise:_a(),dropUndefined:Aa(),exp:Ma(),factorial:za(),find:Pa(),findAll:$a(),flatten:T(),float:Wa(),floor:La(),identity:Za(),indexOf:ye(),inferType:ic(),int:ac(),intersect:lc(),inverse:mc(),isArray:p(),isBoolean:Xe(),isBrowser:gc(),isDataFrame:b(),isEqual:C(),isFunction:_(),isJagged:we(),isNested:Pe(),isNumber:q(),isObject:Y(),isSeries:y(),isString:E(),isUndefined:N(),lerp:yc(),log:wc(),MathError:ne(),max:ce(),mean:it(),median:xc(),min:ot(),mod:Dc(),mode:Ec(),multiply:vn(),ndarray:$(),normal:Cc(),ones:zc(),permutations:Uc(),pow:lt(),print:Pc(),product:Oe(),random:ie().random,range:j(),remap:Yc(),reshape:Le(),reverse:ve(),round:Gc(),scale:le(),seed:ie().seed,Series:ON,set:k(),shape:S(),shuffle:He(),sign:Kc(),sin:Hc(),sort:G(),sqrt:at(),std:ct(),stdev:Zc(),subtract:Sn(),sum:ft(),tan:el(),time:vt().timeSync,timeSync:vt().timeSync,timeAsync:vt().timeAsync,transpose:ee(),union:ol(),variance:bn(),vectorize:w(),zeros:_n(),zip:ul(),dump:function(){let t=typeof global<"u"?global:window;if(!t)throw new fe.MathError("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(fe).forEach(e=>{try{Object.defineProperty(t,e,{configurable:!1,enumerable:!0,writable:!1,value:fe[e]})}catch{t[e]=fe[e]}})}};typeof kn<"u"&&(kn.exports=fe);typeof window<"u"&&(window.JSMathTools=fe)});var U=l((E3,al)=>{al.exports={shouldIgnoreNaNValues:!0}});var he=l((A3,ll)=>{var{assert:DN,flatten:FN,isArray:IN,isDataFrame:_N,isNumber:EN,isSeries:AN}=v();function cl(t){if(_N(t)||AN(t))return cl(t.values);DN(IN(t),"The `containsOnlyNumbers` function only works on arrays, Series, and DataFrames!");let e=FN(t);for(let n=0;n<e.length;n++)if(!EN(e[n]))return!1;return!0}ll.exports=cl});var Rn=l((j3,fl)=>{var{dropMissing:jN,flatten:MN,isArray:CN,isDataFrame:kN,isSeries:zN}=v();function zn(t){return typeof t=="number"?t===0||t===1:kN(t)||zN(t)?zn(t.values):CN(t)?t.length===0?!1:jN(MN(t)).every(n=>zn(n)):!1}fl.exports=zn});var wl=l((M3,Nl)=>{var{abs:hl,apply:dl,assert:ml,clamp:RN,copy:UN,divide:BN,dropNaN:PN,flatten:VN,isArray:JN,isDataFrame:YN,isNumber:pl,isSeries:$N,max:gl,median:ql,min:GN,sort:WN,subtract:yl}=v(),KN=U(),LN=he(),HN=Rn();function bl(t,e){if(YN(t)||$N(t)){let a=t.copy();return a._values=bl(a._values,e),a}if(ml(JN(t),"The `clipOutliers` function only works on arrays, Series, and DataFrames!"),e=e||5,ml(pl(e),"Any `maxScore` value passed into the `clipOutliers` function must be a number!"),!KN.shouldIgnoreNaNValues&&!LN(t))return dl(t,()=>NaN);let n=VN(t),r=PN(n);if(HN(r)||r.length===0)return t;let s=ql(r),o=ql(hl(yl(r,s))),i=!1;if(o===0){let a=WN(UN(r)),c=a.filter(g=>g<s),f=a.filter(g=>g>s),h=s,m=s;if(c.length>0&&(h=gl(c)),f.length>0&&(m=GN(f)),o=(m-h)/2,o===0)return t;i=(s-h)/o>e||(m-s)/o>e}return gl(BN(hl(yl(r,s)),o))>e||i?dl(t,a=>pl(a)?RN(a,s-e*o,s+e*o):a):t}Nl.exports=bl});var Bn=l((C3,Il)=>{var{assert:vl,dropNaN:Sl,isArray:xl,isSeries:Tl,mean:Ol,shape:Dl,variance:Fl}=v(),XN=U();function Un(t,e){if(Tl(t))return Un(t.values,e);if(Tl(e))return Un(t,e.values);vl(xl(t)&&xl(e)&&Dl(t).length===1&&Dl(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),vl(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),XN.shouldIgnoreNaNValues&&(t=Sl(t),e=Sl(e));try{let n=Ol(t),r=Ol(e),s=Math.sqrt((Fl(t)+Fl(e))/2);return(n-r)/s}catch{return NaN}}Il.exports=Un});var jl=l((k3,Al)=>{var{assert:_l,DataFrame:ZN,isArray:QN,isSeries:ew,shape:tw,zeros:nw}=v();function El(t){if(ew(t)){let r=new ZN(El(t.values));return r.index=t.index.slice(),r.columns=t.index.slice(),r}_l(QN(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=tw(t);_l(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=nw([e[0],e[0]]);return t.forEach((r,s)=>n[s][s]=r),n}Al.exports=El});var Yn=l((z3,zl)=>{var{assert:Pn,clamp:rw,correl:Ml,DataFrame:St,dropNaNPairwise:sw,isArray:Cl,isDataFrame:xt,isJagged:kl,isUndefined:ow,ndarray:iw}=v(),uw=U();function Vn(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Jn(t,e){if(ow(e)&&(e=t),xt(t)){let r=new St(Jn(t.values,e));return r.index=t.columns.slice(),r.columns=xt(e)?e.columns.slice():new St(e).columns.slice(),Vn(r)}if(xt(e)){let r=new St(Jn(t,e.values));return r.index=xt(t)?t.columns.slice():new St(t).columns.slice(),r.columns=e.columns.slice(),Vn(r)}Pn(Cl(t)&&Cl(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),Pn(!kl(t)&&!kl(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Pn(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=iw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);uw.shouldIgnoreNaNValues?n[r][o]=Ml(...sw(s,i)):n[r][o]=Ml(s,i)}}return Vn(rw(n,-1,1))}zl.exports=Jn});var $n=l((R3,Rl)=>{function aw(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return t[e]===Symbol.for(e)}catch{return!1}}Rl.exports=aw});var Vl=l((U3,Pl)=>{var{DataFrame:Gn,isArray:cw,isDataFrame:Tt,isNumber:Ul,MathError:lw,sort:fw}=v(),Bl=Yn(),hw=$n();function dw(t,e,n){n=Object.values(arguments).find(o=>Ul(o))||1-1e-5;let r=(()=>{let o=Object.values(arguments).filter(i=>cw(i)||Tt(i));if(o.length===1){let i=o[0];if(hw(i))return Tt(i)?i:new Gn(i);{let u=Bl(i,null);return Tt(u)?u:new Gn(u)}}if(o.length===2){let i=Bl(o[0],o[1]);return Tt(i)?i:new Gn(i)}throw new lw("You must pass 1 or 2 2-dimensional arrays or DataFrames into the `getHighlyCorrelatedColumns` function!")})(),s={};return r.values.forEach((o,i)=>{o.forEach((u,a)=>{if(Ul(u)&&u>n){let c=r.index[i],f=r.columns[a];s[c]||(s[c]=[]),s[c].indexOf(f)<0&&s[c].push(f),s[f]||(s[f]=[]),s[f].indexOf(c)<0&&s[f].push(c)}})}),Object.keys(s).forEach(o=>{s[o]=fw(s[o])}),s}Pl.exports=dw});var Wn=l((B3,Yl)=>{var{dropNaN:mw,isArray:pw,isDataFrame:gw,isNumber:qw,isSeries:yw,pow:bw,sqrt:Nw,sum:ww}=v(),vw=U();function Jl(t){return gw(t)||yw(t)?Jl(t.values):qw(t)?Math.abs(t):pw(t)?(vw.shouldIgnoreNaNValues&&(t=mw(t)),Nw(ww(bw(t,2)))):NaN}Yl.exports=Jl});var Kn=l((P3,Kl)=>{var{assert:$l,DataFrame:Sw,isArray:xw,isSeries:Tw,isString:Ow,isUndefined:Gl,set:Dw,shape:Fw,sort:Iw}=v();function Wl(){if(arguments.length===1&&Tw(arguments[0])){let{name:s,values:o}=arguments[0],i=Wl(s,o),u=new Sw(i);return u.index=arguments[0].index.slice(),u}let[t,e]=arguments;$l(Ow(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),$l(xw(e)&&Fw(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={};return Iw(Dw(e)).filter(s=>typeof s!="number"||s.toString()!=="NaN").filter(s=>!Gl(s)).map(s=>t+"_"+s).slice(0,-1).forEach(s=>{n[s]=e.map(o=>s===t+"_"+o?1:typeof o=="number"&&o.toString()==="NaN"?NaN:Gl(o)?NaN:0)}),n}Kl.exports=Wl});var Hl=l((V3,Ll)=>{var{count:_w}=v();function Ew(t){return _w(t).map(n=>(n.percentage=n.count/t.length,n))}Ll.exports=Ew});var Xl=l((J3,Aw)=>{Aw.exports=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5]});var Hn=l((Y3,uf)=>{var{abs:Zl,assert:jw,dropNaNPairwise:Mw,flatten:Ot,isArray:Ql,isDataFrame:ef,isEqual:Cw,isSeries:tf,mean:nf,remap:kw,round:zw,shape:rf,sqrt:Rw,std:sf}=v(),Uw=U(),of=Xl();function Bw(t){return Zl(t)>4.1?0:of[zw(kw(Zl(t),0,4.1,0,of.length))]}function Ln(t,e){if(ef(t)||tf(t))return Ln(t.values,e);if(ef(e)||tf(e))return Ln(t,e.values);jw(Ql(t)&&Ql(e)&&Cw(rf(t),rf(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,r]=Uw.shouldIgnoreNaNValues?Mw(Ot(t),Ot(e)):[Ot(t),Ot(e)];if(n.length===0||r.length===0)return NaN;let s=nf(n),o=nf(r),i=sf(n),u=sf(r),a=n.length,c=r.length,f=(s-o)/Rw(i*i/a+u*u/c);return 2*Bw(f)}uf.exports=Ln});var hf=l(($3,ff)=>{var{assert:Xn,clamp:Pw,DataFrame:Dt,dropNaNPairwise:Vw,isArray:af,isDataFrame:Ft,isJagged:cf,isUndefined:Jw,ndarray:Yw}=v(),$w=U(),lf=Hn();function Zn(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Qn(t,e){if(Jw(e)&&(e=t),Ft(t)){let r=new Dt(Qn(t.values,e));return r.index=t.columns.slice(),r.columns=Ft(e)?e.columns.slice():new Dt(e).columns.slice(),Zn(r)}if(Ft(e)){let r=new Dt(Qn(t,e.values));return r.index=Ft(t)?t.columns.slice():new Dt(t).columns.slice(),r.columns=e.columns.slice(),Zn(r)}Xn(af(t)&&af(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),Xn(!cf(t)&&!cf(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Xn(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=Yw([t[0].length,e[0].length]);for(let r=0;r<t[0].length;r++){let s=t.map(o=>o[r]);for(let o=0;o<e[0].length;o++){let i=e.map(u=>u[o]);$w.shouldIgnoreNaNValues?n[r][o]=lf(...Vw(s,i)):n[r][o]=lf(s,i)}}return Zn(Pw(n,0,1))}ff.exports=Qn});var qf=l((G3,gf)=>{var{assert:It,intersect:Gw,isDataFrame:df,isSeries:mf,isUndefined:pf}=v(),de=class{constructor(e){let n=this;It(pf(e)||e===de.DROP_NAN_MODE||e===de.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=pf(e)?de.DROP_MISSING_MODE:e,n.index=null}fit(){let e=this,n=[];return Object.values(arguments).forEach(r=>{It(df(r)||mf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===de.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),e.index=Gw(...n),e}transform(){let e=this;It(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(It(df(r)||mf(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(e.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ce=de;Ct(Ce,"DROP_NAN_MODE","DROP_NAN_MODE"),Ct(Ce,"DROP_MISSING_MODE","DROP_MISSING_MODE");gf.exports=Ce});var tr=l((W3,vf)=>{var{assert:er,isArray:Ww,isBoolean:Kw,isDataFrame:yf,isSeries:bf,int:Lw,isNumber:Hw,isUndefined:Nf,range:wf,set:Xw,shape:Zw,shuffle:Qw}=v();vf.exports=function(){let e=Array.from(arguments),n=e.find(g=>Kw(g)),r=Nf(n)?!0:n,s=e.find(g=>Hw(g)),o=Nf(s)?.1:s;er(o>0&&o<1,"`testSize` must be a number between 0 and 1 (exclusive on both ends)!");let i=e.filter(g=>Ww(g)||yf(g)||bf(g));er(i.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let u=i.map(g=>Zw(g)[0]);er(Xw(u).length===1,`All datasets passed into the \`trainTestSplit\` function must be the same length at their shallowest dimension! The lengths of your datasets, though, are: ${u.join(", ")}`);let a=[],c=r?Qw(wf(0,u[0])):wf(0,u[0]),f=Lw((1-o)*c.length),h=c.slice(0,f),m=c.slice(f);return i.forEach(g=>{if(yf(g))a.push(g.get(h,null)),a.push(g.get(m,null));else if(bf(g))a.push(g.get(h)),a.push(g.get(m));else{let F=[],O=[];g.forEach((B,qe)=>{h.indexOf(qe)>-1?F.push(B):O.push(B)}),a.push(F),a.push(O)}}),a}});var Et=l((K3,Ff)=>{var{add:ev,argmin:tv,assert:nv,flatten:Sf,isArray:rv,isDataFrame:xf,isEqual:sv,int:ov,isNumber:iv,isSeries:Tf,normal:nr,pow:uv,random:av,range:cv,scale:lv,shape:_t,subtract:fv,sum:hv}=v(),dv=tr();function rr(t,e){(xf(t)||Tf(t))&&(t=t.values),(xf(e)||Tf(e))&&(e=e.values),nv(sv(_t(t),_t(e)),"`yPred` and `yTrue` must have the same shape!");let n=Sf(t),r=Sf(e),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function mv(t){test(`tests that the \`${t.name}\` model works correctly`,()=>{let e=nr([5,10]).map(h=>h.map(m=>m*100+nr()*100)),n=[],r=cv(0,500).map(()=>{let h=ov(av()*e.length),m=e[h];return n.push(h),ev(m,lv(5,nr(_t(m))))}),[s,o,i,u]=dv(r,n),a=new t({k:e.length});a.fit(s),a.centroids=Of(e,a.centroids);let c=a.predict(s),f=a.predict(o);expect(rr(i,c)).toBeGreaterThan(.95),expect(rr(u,f)).toBeGreaterThan(.95)})}function pv(t){return rv(t)&&_t(t).length===2}function gv(t){return iv(t)&&parseInt(t)===t&&t>=0}function Of(t,e){return t.map(n=>e[tv(e.map(r=>Df(n,r)))])}function Df(t,e){return hv(uv(fv(t,e),2))}Ff.exports={accuracy:rr,createGenericTest:mv,isMatrix:pv,isWholeNumber:gv,orderCentroids:Of,sse:Df}});var ir=l((L3,Af)=>{var{add:If,argmin:qv,assert:te,copy:yv,distance:_f,divide:bv,isDataFrame:Nv,isFunction:wv,isUndefined:At,normal:vv,random:Sv,range:xv,scale:Tv,shuffle:Ov,zeros:Ef}=v(),{isMatrix:Dv,isWholeNumber:sr,sse:Fv}=Et(),or=class{constructor(e){te(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),te(sr(e.k),"`k` must be a whole number!"),te(sr(e.maxIterations)||At(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),te(sr(e.maxRestarts)||At(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),te(typeof e.tolerance=="number"||At(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.k=e.k,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.centroids=null}initializeCentroids(e){let n=this;return Ov(e).slice(0,n.k)}getFitStepFunction(e,n){let r=this;te(Dv(e),"`x` must be a matrix!"),Nv(e)&&(e=e.values),At(n)||te(wv(n),"If defined, `progress` must be a function!");let s=r.initializeCentroids(e),o={currentRestart:0,currentIteration:0,currentCentroids:s,bestCentroids:s,bestScore:-1/0,isFinished:!1};return function(){let u=r.predict(e,o.currentCentroids),a=[],c=Ef(r.k);e.forEach((h,m)=>{let g=u[m];a[g]||(a[g]=Ef(h.length)),a[g]=If(a[g],h),c[g]++});let f=xv(0,r.k).map(h=>c[h]===0?If(o.currentCentroids[parseInt(Sv()*o.currentCentroids.length)],Tv(.001,vv(o.currentCentroids[0].length))):bv(a[h],c[h]));if(_f(o.currentCentroids,f)<r.tolerance?o.currentIteration=r.maxIterations-1:o.currentCentroids=f,n&&n((o.currentRestart+o.currentIteration/r.maxIterations)/r.maxRestarts,r),o.currentIteration++,o.currentIteration>=r.maxIterations){let h=r.score(e,o.currentCentroids);if(h>o.bestScore&&(o.bestScore=h,o.bestCentroids=yv(o.currentCentroids)),o.currentIteration=0,o.currentRestart++,o.currentRestart>=r.maxRestarts)o.isFinished=!0,r.centroids=o.bestCentroids,n&&n(1,r);else{let m=r.initializeCentroids(e);o.currentCentroids=m}}return o}}fit(e,n){let r=this,s=r.getFitStepFunction(e,n),o;for(;!o||!o.isFinished;)o=s();return r}predict(e,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(s=>qv(n.map(o=>_f(s,o))))}score(e,n){let r=this;if(n=n||r.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=r.predict(e,n).map(i=>n[i]);return-Fv(e,o)}};Af.exports=or});var ar=l((H3,Cf)=>{var{argmin:Iv,distance:jf,divide:_v,max:Ev,random:Mf}=v(),Av=ir(),ur=class extends Av{initializeCentroids(e){let n=this,r=[e[parseInt(Mf()*e.length)]];for(;r.length<n.k;){let s=e.map(i=>jf(i,r[Iv(r.map(u=>jf(i,u)))])),o=_v(s,Ev(s));r.push(e[o.findIndex(i=>Mf()<i)])}return r}};Cf.exports=ur});var Rf=l((X3,zf)=>{var{assert:J,isArray:jv,isDataFrame:Mv,isEqual:Cv,isFunction:kv,isUndefined:me,range:zv,shape:kf}=v(),{isMatrix:Rv,isWholeNumber:cr}=Et(),Uv=ar(),lr=class{constructor(e){me(e)&&(e={}),J(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),me(e.ks)&&(e.ks=zv(1,16)),J(jv(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{J(cr(r),"`ks` must be an array of whole numbers!")}),J(cr(e.maxIterations)||me(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),J(cr(e.maxRestarts)||me(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),J(typeof e.tolerance=="number"||me(e.tolerance),"`tolerance` must be a number or undefined!");let n=this;n.ks=e.ks,n.maxRestarts=e.maxRestarts||25,n.maxIterations=e.maxIterations||100,n.tolerance=e.tolerance||1e-4,n.scoreStopRatio=e.scoreStopRatio||.85,n.modelClass=e.modelClass||Uv,n.fittedModel=null}getFitStepFunction(e,n){let r=this;J(Rv(e),"`x` must be a matrix!"),Mv(e)&&(e=e.values),me(n)||J(kv(n),"If defined, `progress` must be a function!");let s={isFinished:!1,lastScore:-1/0,currentIndex:0};return function(){let i=r.ks[s.currentIndex],u=new r.modelClass({k:i,maxRestarts:10,maxIterations:20});u.fit(e,c=>n?n((s.currentIndex+c)/(r.ks.length+1)):null);let a=u.score(e);return a/s.lastScore>r.scoreStopRatio?(s.isFinished=!0,s.currentIndex--):(s.lastScore=a,s.currentIndex+1>=r.ks.length?s.isFinished=!0:s.currentIndex++),s.isFinished&&(r.fittedModel=new r.modelClass({k:r.ks[s.currentIndex],maxRestarts:r.maxRestarts,maxIterations:r.maxIterations}),r.fittedModel.fit(e,c=>n?n((r.ks.length+c)/(r.ks.length+1)):null),n&&n(1)),s}}fit(e,n){let r=this,s=r.getFitStepFunction(e,n),o;for(;!o||!o.isFinished;)o=s();return r}predict(e,n){return this.fittedModel.predict(e,n)}score(e,n){return this.fittedModel.score(e,n)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){let n=this;J(Cv(kf(e),kf(n.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),n.fittedModel.centroids=e}};zf.exports=lr});var Bf=l((Z3,Uf)=>{Uf.exports={KMeansMeta:Rf(),KMeansNaive:ir(),KMeansPlusPlus:ar(),helpers:Et()}});var fr=l((Q3,Gf)=>{var{apply:Bv,assert:Pv,dropNaN:Pf,isArray:Vv,isDataFrame:Jv,isSeries:Yv,mean:Vf,std:Jf}=v(),Yf=U();function $f(t){if(Jv(t)||Yv(t)){let r=t.copy();return r.values=$f(r.values),r}Pv(Vv(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let e=(()=>Yf.shouldIgnoreNaNValues?Vf(Pf(t)):Vf(t))(),n=(()=>Yf.shouldIgnoreNaNValues?Jf(Pf(t)):Jf(t))();return n===0?t:Bv(t,r=>(r-e)/n)}Gf.exports=$f});var dr=l((e4,Xf)=>{var{assert:pe,dot:Wf,isArray:Kf,isSeries:hr,scale:$v,Series:Gv,shape:Lf}=v(),Hf=he();function jt(t,e){if(hr(t)){if(hr(e))return new Gv(jt(t.values,e.values));{let n=t.copy();return n.values=jt(t.values,e),n}}if(hr(e)){let n=e.copy();return n.values=jt(t,e.values),n}return pe(Kf(t),"`project` only works on vectors!"),pe(Kf(e),"`project` only works on vectors!"),pe(Hf(t),"`project` only works on vectors of numbers!"),pe(Hf(e),"`project` only works on vectors of numbers!"),pe(Lf(t).length===1,"`project` only works on vectors!"),pe(Lf(e).length===1,"`project` only works on vectors!"),$v(Wf(e,t)/Wf(e,e),e)}Xf.exports=jt});var nh=l((t4,th)=>{var{assert:Zf,copy:Wv,DataFrame:Kv,divide:Lv,isArray:Hv,isDataFrame:Xv,isJagged:Zv,shape:Qv,subtract:eS,transpose:Qf}=v(),tS=he(),nS=Wn(),rS=dr();function eh(t){if(Xv(t)){let s=new Kv(eh(t.values));return s.index=t.index.slice(),s.columns=t.columns.slice(),s}Zf(Hv(t)&&!Zv(t)&&Qv(t).length===2,"`orthonormalize` only works on matrices!"),Zf(tS(t),"`orthonormalize` only works on matrices of numbers!");let e=Qf(t),n=[];e.forEach(s=>{let o=Wv(s);n.forEach(i=>{o=eS(o,rS(o,i))}),n.push(o)});let r=n.map(s=>Lv(s,nS(s)));return Qf(r)}th.exports=eh});var sh=l((n4,rh)=>{function sS(t){if(typeof t!="string")throw new Error("`text` must be a string!");t=t.trim();let e="",n=!1;for(let r=0;r<t.length;r++){let s=t[r];s.match(/[A-Za-z0-9]/g)?(e.length===0?e+=s.toLowerCase():n?e+=s.toUpperCase():e+=s,n=!1):!s.includes("'")&&!s.includes("\u2019")&&!s.includes("\u275C")&&(n=!0)}return e}rh.exports=sS});var ih=l((r4,oh)=>{function oS(t,e){return e=e||"",t.split(`
`).map(n=>n.trim().length>0?e+n:n).join(`
`)}oh.exports=oS});var ah=l((s4,uh)=>{function iS(t,e,n){if(typeof t!="string")throw new Error("`text` must be a string!");if(typeof e!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return t.split(e).join(n)}uh.exports=iS});var lh=l((o4,ch)=>{ch.exports="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65"});var mr=l((i4,dh)=>{var uS=ah(),aS=lh(),fh="  ",hh=" ";function cS(t){if(typeof t!="string")throw new Error("`text` must be a string!");let e="";for(let n=0;n<t.length;n++){let r=t[n].toLowerCase();aS.includes(r)?e+=hh:e+=r}for(;e.includes(fh);)e=uS(e,fh,hh);return e.trim()}dh.exports=cS});var ph=l((u4,mh)=>{var lS=mr();function fS(t){if(typeof t!="string")throw new Error("`text` must be a string!");let e=lS(t).split(" ");return e.length===0?"":e.length===1?e[0]:e.join("-")}mh.exports=fS});var qh=l((a4,gh)=>{var hS=mr();function dS(t){if(typeof t!="string")throw new Error("`text` must be a string!");let e=hS(t).split(" ");return e.length===0?"":e.length===1?e[0]:e.join("_")}gh.exports=dS});var bh=l((c4,yh)=>{var{decycle:mS}=v();function pS(t,e,n){return JSON.stringify(mS(t),e,n)}yh.exports=pS});var wh=l((l4,Nh)=>{function gS(t){let e=t.split(`
`),n=e.filter(s=>s.trim().length>0).map(s=>s.split("").findIndex(o=>!o.match(/\s/g))),r=Math.min(...n);return e.map(s=>s.substring(r)).join(`
`)}Nh.exports=gS});var Sh=l((f4,vh)=>{function qS(t,e){if(typeof t!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof e>"u"||e===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?e=process.stdout.columns>80?80:process.stdout.columns:e=80),isNaN(e)||typeof e!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return t.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let s=r.split(/[^\s]/g)[0],o=r.replace(s,"").split(" "),i=s;o.forEach(u=>{let a=i+(i.trim().length>0?" ":"")+u;a.length>e?(n.push(i),i=s+u):i=a}),i.length>0&&n.push(i)}),n.join(`
`)}vh.exports=qS});var xh=l((h4,pr)=>{var ke={camelify:sh(),indent:ih(),kebabify:ph(),snakeify:qh(),stringify:bh(),unindent:wh(),wrap:Sh(),dump(){Object.keys(ke).forEach(t=>{typeof global<"u"&&(global[t]=ke[t]),typeof window<"u"&&(window[t]=ke[t])})}};typeof pr<"u"&&(pr.exports=ke);typeof window<"u"&&(window.JSTextTools=ke)});var Eh=l((d4,_h)=>{var{assert:ge,correl:Th,count:yS,DataFrame:Oh,inferType:bS,isArray:NS,isDataFrame:wS,isFunction:vS,isJagged:SS,isNumber:ze,isUndefined:Dh,shape:xS,sort:TS,sum:OS}=v(),{stringify:DS}=xh(),FS=Kn(),Fh=t=>ze(t)&&(parseInt(t)===t||t===1/0);function Ih(t,e){e=e||{};let n=ze(e.maxUniqueValues)?e.maxUniqueValues:7,r=ze(e.minNonMissingValues)?e.minNonMissingValues:15,s=ze(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,o=e.progress||null;if(NS(t))return ge(xS(t).length===2&&!SS(t),"The `convertToNumerical` function only works on non-jagged 2-dimensional arrays and DataFrames!"),Ih(new Oh(t));ge(wS(t),"You must pass a DataFrame into the `convertToNumerical` function!"),ge(Fh(n),"`maxUniqueValues` must be a whole number!"),ge(Fh(r),"`minNonMissingValues` must be a whole number!"),ge(ze(s),"`maxCorrelationThreshold` must be a number!"),Dh(o)||ge(vS(o),"If defined, `progress` must be a function!");let i={};return t.apply((u,a)=>{o&&o(a/t.columns.length);let c=bS(u.values);if(c.type==="boolean"&&(c.values=c.values.map(h=>h?1:0)),c.type==="date"&&(c.values=c.values.map(h=>{try{return h.getTime()}catch{return NaN}})),c.type==="null")return;c.type,c.type==="object"&&(c.values=c.values.map(h=>DS(h))),c.type;let f=c.values.filter(h=>!Dh(h));if(!(c.values.length-f.length>r)){if(c.type!=="boolean"){let h=TS(yS(f),(g,F)=>F.count-g.count);if(OS(h.slice(0,n).map(g=>g.count))/f.length>=.9){if(h.length<2)return;let g=FS(u.name,c.values);for(;Object.keys(g).length>0;){let F=Object.keys(g)[0],O=g[F];delete g[F];let B=Object.keys(i);for(let qe=0;qe<B.length;qe++){let id=i[B[qe]];if(Th(O,id)>s)return}i[F]=O}return}if(c.type==="object"||c.type==="string")return}if(c.type==="boolean"||c.type==="date"||c.type==="number"){let h=Object.keys(i);for(let m=0;m<h.length;m++){let g=i[h[m]];if(Th(c.values,g)>s)return}i[u.name]=c.values}}}),new Oh(i)}_h.exports=Ih});var Ph=l((m4,Bh)=>{var{abs:IS,add:_S,assert:Re,isArray:Ah,isDataFrame:jh,isEqual:ES,isSeries:Mh,mean:AS,pow:Ch,scale:jS,shape:kh,sign:MS,sqrt:CS,sum:zh}=v(),Rh=he(),Uh=(t,e)=>_S(t,jS(e,-1));function gr(t,e){if(jh(t)||Mh(t))return gr(t.values,e);if(jh(e)||Mh(e))return gr(t,e.values);Re(Ah(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Ah(e),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(ES(kh(t),kh(e)),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Rh(t),"You must pass two same-shaped numerical arrays into the `rScore` function!"),Re(Rh(e),"You must pass two same-shaped numerical arrays into the `rScore` function!");let n=zh(Ch(Uh(t,e),2)),r=zh(Ch(Uh(t,AS(t)),2));if(r===0)return NaN;let s=1-n/r;return MS(s)*CS(IS(s))}Bh.exports=gr});var Gh=l((p4,$h)=>{var{argmax:Vh,assert:Ue,copy:kS,DataFrame:zS,dot:RS,isArray:US,isDataFrame:BS,isEqual:Jh,isJagged:PS,isNumber:VS,reverse:JS,shape:YS,transpose:$S}=v();function Yh(t){if(US(t)){Ue(YS(t).length===2&&!PS(t),"The `sortCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!");let u=new zS(t);return u.index=u.columns.slice(),Yh(u).values}Ue(BS(t),"You must pass a 2-dimensional array or DataFrame into the `sortCorrelationMatrix` function!");let e=t.copy(),n=[];e.values.forEach((u,a)=>{u.forEach((c,f)=>{VS(c)?Ue(c>=-1&&c<=1,"The correlation matrix passed into the `sortCorrelationMatrix` function must not contain values less than -1 or greater than 1!"):(n.push({row:e.index[a],col:e.columns[f],value:c}),e.values[a][f]=-1/0)})}),Ue(Jh(e.values,$S(e.values)),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical!"),Ue(Jh(e.index,e.columns),"The correlation matrix passed into the `sortCorrelationMatrix` function must be symmetrical! (In this case, although the values themselves are symmetrical, the row and column names differ.)");let r=kS(e.index),s=[];for(;r.length>0;)if(s.length===0){let u=Vh(e.values.map(a=>RS(a,a)));s.push(r[u]),r.splice(u,1)}else{let u=e.index.indexOf(s.at(-1)),a=Vh(r.map(f=>e.values[e.index.indexOf(f)][u])),c=r[a];s.push(c),r.splice(a,1)}let o=JS(s),i=e.get(o,o);return n.forEach(u=>{let a=i.index.indexOf(u.row),c=i.columns.indexOf(u.col);i.values[a][c]=u.value,i.values[c][a]=u.value}),i}$h.exports=Yh});var Kh=l((g4,Wh)=>{var GS=fr();function WS(){return GS(...arguments)}Wh.exports=WS});var rd=l((q4,nd)=>{var{assert:Mt,DataFrame:Lh,dropNaN:KS,flatten:Hh,isArray:LS,isDataFrame:qr,isSeries:yr,mean:Xh,range:HS,Series:Zh,shape:Qh,stdev:ed,transpose:td}=v(),XS=U(),br=class{constructor(){let e=this;e.means=[],e.stdevs=[],e.wasFittedOnAVector=!1,e.hasBeenFitted=!1}_getDataArrayAndShape(e){if(qr(e))return[e.values,e.shape];if(yr(e)){let r=td([e.values]);return[r,Qh(r)]}Mt(LS(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=Qh(e);return Mt(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),e=td([e])),[e,n]}fit(e){let n=this,r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];return n.wasFittedOnAVector=s.indexOf(1)>-1,n.means=[],n.stdevs=[],HS(0,s[1]).forEach(o=>{let i=e.map(u=>u[o]);if(XS.shouldIgnoreNaNValues){let u=KS(i);n.means.push(Xh(u)),n.stdevs.push(ed(u))}else n.means.push(Xh(i)),n.stdevs.push(ed(i))}),n.hasBeenFitted=!0,n}transform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(qr(e)){let i=new Lh(n.transform(e.values));return i.columns=e.columns,i.index=e.index,i}if(yr(e)){let i=new Zh(n.transform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];Mt(s[1]===n.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>(u-n.means[a])/n.stdevs[a]));return n.wasFittedOnAVector?Hh(o):o}untransform(e){let n=this;if(!n.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(qr(e)){let i=new Lh(n.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(yr(e)){let i=new Zh(n.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=n._getDataArrayAndShape(e);e=r[0];let s=r[1];Mt(s[1]===n.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((u,a)=>u*n.stdevs[a]+n.means[a]));return n.wasFittedOnAVector?Hh(o):o}};nd.exports=br});var QS=l((y4,od)=>{var{MathError:ZS}=v(),sd={clipOutliers:wl(),cohensD:Bn(),cohensd:Bn(),common:U(),containsOnlyNumbers:he(),diagonalize:jl(),getCorrelationMatrix:Yn(),getHighlyCorrelatedColumns:Vl(),getMagnitude:Wn(),getOneHotEncodings:Kn(),getPercentages:Hl(),getPValueMatrix:hf(),IndexMatcher:qf(),isBinary:Rn(),isCorrelationMatrix:$n(),KMeans:Bf(),normalize:fr(),orthonormalize:nh(),convertToNumerical:Eh(),project:dr(),pValue:Hn(),rScore:Ph(),sortCorrelationMatrix:Gh(),standardize:Kh(),StandardScaler:rd(),trainTestSplit:tr(),dump(){let t=this,e=typeof global<"u"?global:typeof window<"u"?window:null;if(!e)throw new ZS("Cannot dump functions into global scope because neither `global` nor `window` exist in the current context!");Object.keys(t).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:t[n]})}catch{e[n]=t[n]}})}};try{window.JSDataScienceHelpers=sd}catch{}try{od.exports=sd}catch{}});QS();})();
